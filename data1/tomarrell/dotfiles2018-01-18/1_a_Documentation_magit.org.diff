diff --git a/Documentation/magit.org b/Documentation/magit.org
index d6636ca..dab79b0 100644
--- a/Documentation/magit.org
++ b/Documentation/magit.org
@@ -1,25 +1,18 @@
 #+TITLE: Magit User Manual
 #+AUTHOR: Jonas Bernoulli
 #+EMAIL: jonas@bernoul.li
-#+DATE: 2015-2017
#+DATE: 2015-2018
 #+LANGUAGE: en
 
 #+TEXINFO_DIR_CATEGORY: Emacs
 #+TEXINFO_DIR_TITLE: Magit: (magit).
 #+TEXINFO_DIR_DESC: Using Git from Emacs with Magit.
-#+SUBTITLE: for version 2.10
#+SUBTITLE: for version 2.11.0 (2.11.0-411-g73ea37afb+1)
#+BIND: ox-texinfo+-before-export-hook ox-texinfo+-update-version-strings
 
 #+TEXINFO_DEFFN: t
-#+TEXINFO_CLASS: info+
-#+OPTIONS: H:4 num:nil toc:2
#+OPTIONS: H:4 num:3 toc:2
 
-* Copying
-:PROPERTIES:
-:COPYING:    t
-:END:
-
-#+BEGIN_EXPORT texinfo
-@ifnottex
 Magit is an interface to the version control system Git, implemented
 as an Emacs package.  Magit aspires to be a complete Git porcelain.
 While we cannot (yet) claim that Magit wraps and improves upon each
@@ -27,10 +20,12 @@ and every Git command, it is complete enough to allow even experienced
 Git users to perform almost all of their daily version control tasks
 directly from within Emacs.  While many fine Git clients exist, only
 Magit and Git itself deserve to be called porcelains.
-@end ifnottex
 
-@quotation
-Copyright (C) 2015-2017 Jonas Bernoulli <jonas@@bernoul.li>
#+TEXINFO: @noindent
This manual is for Magit version 2.11.0 (2.11.0-411-g73ea37afb+1).

#+BEGIN_QUOTE
Copyright (C) 2015-2018 Jonas Bernoulli <jonas@bernoul.li>
 
 You can redistribute this document and/or modify it under the terms
 of the GNU General Public License as published by the Free Software
@@ -41,8 +36,7 @@ This document is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.
-@end quotation
-#+END_EXPORT
#+END_QUOTE
 
 * Introduction
 
@@ -123,6 +117,7 @@ porcelain commands: ~add~, ~am~, ~bisect~, ~blame~, ~branch~, ~checkout~, ~cherr
 commands are implemented on top of Git plumbing commands.
 
 * Installation
** _ :ignore:
 
 Magit can be installed using Emacs' package manager or manually from
 its development repository.
@@ -154,53 +149,55 @@ yourself with it by reading the documentation in the Emacs manual, see
 Once you have added your preferred archive, you need to update the
 local package list using:
 
-#+BEGIN_SRC undefined
#+BEGIN_EXAMPLE
   M-x package-refresh-contents RET
-#+END_SRC
#+END_EXAMPLE
 
 Once you have done that, you can install Magit and its dependencies
 using:
 
-#+BEGIN_SRC undefined
#+BEGIN_EXAMPLE
   M-x package-install RET magit RET
-#+END_SRC
#+END_EXAMPLE
 
 Now see [[*Post-Installation Tasks]].
 
 ** Installing from the Git Repository
 
-Magit depends on the ~dash~ and ~with-editor~ library which are available
-from Melpa and Melpa-Stable.  Install them using ~M-x package-install
-RET <package> RET~.  Of course you may also install them manually from
-their development repository, but I won't cover that here.
Magit depends on the ~dash~, ~magit-popup~, ~ghub~ and ~with-editor~ libraries
which are available from Melpa and Melpa-Stable.  Install them using ~M-x
package-install RET <package> RET~.  Of course you may also install
them manually from their development repository.
 
-(An older release of Magit is also available from Marmalade, but no
-new versions will be uploaded in the future.  Marmalade's maintainer
-has stopped responding to requests from package maintainers who are
-having difficulties or require him to create an account so that they
-can upload their packages in the first place.)
(An ancient release of Magit is also available from Marmalade, but
no new versions will be uploaded.  Marmalade is unmaintained ¡ª its
maintainer has stopped responding to support requests from package
authors or even just to create new accounts so that new authors can
upload their packages in the first place.)
 
 Then clone the Magit repository:
 
-#+BEGIN_SRC shell
#+BEGIN_SRC shell-script
   $ git clone https://github.com/magit/magit.git ~/.emacs.d/site-lisp/magit
   $ cd ~/.emacs.d/site-lisp/magit
 #+END_SRC
 
 Then compile the libraries and generate the info manuals:
 
-#+BEGIN_SRC shell
#+BEGIN_SRC shell-script
   $ make
 #+END_SRC
 
-If you haven't installed ~dash~ and ~with-editor~ using Elpa or at
-~/path/to/magit/../<package>~, then you have to tell ~make~ where to find
-them.  To do so create ~/path/to/magit/config.mk~ with the following
-content before running ~make~:
If you haven't installed ~dash~, ~magit-popup~, ~ghub~ and ~with-editor~ from
Melpa or at ~/path/to/magit/../<package>~, then you have to tell ~make~ where
to find them.  To do so create the file ~/path/to/magit/config.mk~ with the
following content before running ~make~:
 
 #+BEGIN_SRC makefile
   LOAD_PATH  = -L /path/to/magit/lisp
   LOAD_PATH += -L /path/to/dash
  LOAD_PATH += -L /path/to/magit-popup
  LOAD_PATH += -L /path/to/ghub
   LOAD_PATH += -L /path/to/with-editor
 #+END_SRC
 
@@ -233,7 +230,7 @@ directory using ~sudo make install~ and setting ~load-path~ accordingly.
 
 To update Magit use:
 
-#+BEGIN_SRC shell
#+BEGIN_SRC shell-script
   $ git pull
   $ make
 #+END_SRC
@@ -251,15 +248,15 @@ Magit, Git, and Emacs releases you think you are using.  It's best to
 restart Emacs before doing so, to make sure you are not using an
 outdated value for ~load-path~.
 
-#+BEGIN_SRC undefined
#+BEGIN_EXAMPLE
   M-x magit-version RET
-#+END_SRC
#+END_EXAMPLE
 
 should display something like
 
-#+BEGIN_SRC undefined
#+BEGIN_EXAMPLE
   Magit 2.8.0, Git 2.10.2, Emacs 25.1.1, gnu/linux
-#+END_SRC
#+END_EXAMPLE
 
 Then you might also want to read about options that many users likely
 want to customize.  See [[*Essential Settings]].
@@ -271,6 +268,9 @@ See [[*How to install the gitman info manual?]].
 
 If you are completely new to Magit then see [[*Getting Started]].
 
If you run into problems, then please see the [[*FAQ]].  Also see the
[[*Debugging Tools]].

 And last but not least please consider making a donation, to ensure
 that I can keep working on Magit.  See https://magit.vc/donations.
 for various donation options.
@@ -383,6 +383,7 @@ then it is highly recommended that you read the next section too.
 
 * Interface Concepts
 ** Modes and Buffers
*** _ :ignore:
 
 Magit provides several major-modes.  For each of these modes there
 usually exists only one buffer per repository.  Separate modes and
@@ -567,9 +568,14 @@ buffers whose major-modes derive from ~magit-mode~.
     The top-level directory of the working tree of the repository, or
     if ~magit-uniquify-buffer-names~ is non-nil an abbreviation of that.
 
-  The value should always contain either ~%m~ or ~%M~, ~%v~ or ~%V~, and ~%t~.
  - ~%T~

    Like ~%t~, but append an asterisk if and only if
    ~magit-uniquify-buffer-names~ is nil.

  The value should always contain ~%m~ or ~%M~, ~%v~ or ~%V~, and ~%t~ or ~%T~.
   If ~magit-uniquify-buffer-names~ is non-nil, then the value must end
-  with ~%t~.
  with ~%t~ or ~%T~ (see issue #2841).
 
 - User Option: magit-uniquify-buffer-names
 
@@ -853,6 +859,7 @@ buffer) and you would not be asked whether you want to save the buffer
 (because it isn't modified).
 
 ** Sections
*** _ :ignore:
 
 Magit buffers are organized into nested sections, which can be
 collapsed and expanded, similar to how sections are handled in Org
@@ -899,8 +906,7 @@ the following commands.
   Move to the beginning of the parent of the current section.
 
 The above commands all call the hook ~magit-section-movement-hook~.
-And, except for the second, the below functions are all members of
-that hook's default value.
Any of the functions listed below can be used as members of this hook.
 
 - Variable: magit-section-movement-hook
 
@@ -911,7 +917,7 @@ that hook's default value.
 
   This hook function ensures that the beginning of the current section
   is visible, provided it is a ~hunk~ section.  Otherwise, it does
-  nothing.
  nothing.  This function is a member of the hook's default value.
 
 - Function: magit-section-set-window-start
 
@@ -924,13 +930,15 @@ that hook's default value.
 
   This hook function only has an effect in log buffers, and ~point~ is
   on the "show more" section.  If that is the case, then it doubles
-  the number of commits that are being shown.
  the number of commits that are being shown.  This function is a
  member of the hook's default value.
 
 - Function: magit-log-maybe-update-revision-buffer
 
   When moving inside a log buffer, then this function updates the
   revision buffer, provided it is already being displayed in another
-  window of the same frame.
  window of the same frame.  This function is a member of the hook's
  default value.
 
 - Function: magit-log-maybe-update-blob-buffer
 
@@ -1038,6 +1046,15 @@ then the previous visibility is preserved. The initial visibility of
 certain sections can also be overwritten using the hook
 ~magit-section-set-visibility-hook~.
 
- User Option: magit-section-cache-visibility-types

  This option controls for which sections the previous visibility
  state should be restored if a section disappears and later appears
  again.  The value is a list of section types.

  This requires that ~magit-section-cached-visibility~ is a member of
  ~magit-section-set-visibility-hook~.

 - Variable: magit-section-set-visibility-hook
 
   This hook is run when first creating a buffer and also when
@@ -1162,72 +1179,395 @@ you should setup a global binding:
   (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
 #+END_SRC
 
-** Completion and Confirmation
Most popups set their initial arguments according to the corresponding
~magit-*-arguments~ variable.  Two popups, the log and diff popups
(see [[*Logging]] and [[*Diffing]]), may behave a bit differently, depending
on the value of ~magit-use-sticky-arguments~.

- User Option: magit-use-sticky-arguments

  This option controls how diff and log commands reuse arguments from
  existing buffers.

  When ~t~ (the default value), the log or diff popup reuses the
  arguments from the current repository's log or diff buffer,
  respectively.  When no log or diff buffer exists for the current
  repository, these popups use the default value of
  ~magit-log-arguments~ or ~magit-diff-arguments~.

  When ~current~, log and diff popups will only reuse the arguments if
  the current buffer is derived from ~magit-log-mode~ or
  ~magit-diff-mode~, respectively.

  When ~nil~, the default value of ~magit-log-arguments~ or
  ~magit-diff-arguments~ is always used.

** Completion, Confirmation and the Selection
*** Action Confirmation

By default many actions that could potentially lead to data loss have
to be confirmed.  This includes many very common actions, so this can
quickly become annoying.  Many of these actions can be undone and if
you have thought about how to undo certain mistakes, then it should
be safe to disable confirmation for the respective actions.

The option ~magit-no-confirm~ can be used to tell Magit to perform
certain actions without the user having to confirm them.  Note that
while this option can only be used to disable confirmation for a
specific set of actions, the next section explains another way of
telling Magit to ask fewer questions.

- User Option: magit-no-confirm

  The value of this option is a list of symbols, representing actions
  that do not have to be confirmed by the user before being carried
  out.

  By default many potentially dangerous commands ask the user for
  confirmation.  Each of the below symbols stands for an action which,
  when invoked unintentionally or without being fully aware of the
  consequences, could lead to tears.  In many cases there are several
  commands that perform variations of a certain action, so we don't
  use the command names but more generic symbols.

  - Applying changes:

    - ~discard~ Discarding one or more changes (i.e. hunks or the
      complete diff for a file) loses that change, obviously.

    - ~reverse~ Reverting one or more changes can usually be undone by
      reverting the reversion.

    - ~stage-all-changes~, ~unstage-all-changes~ When there are both
      staged and unstaged changes, then un-/staging everything would
      destroy that distinction.  Of course that also applies when
      un-/staging a single change, but then less is lost and one does
      that so often that having to confirm every time would be
      unacceptable.

  - Files:

    - ~delete~ When a file that isn't yet tracked by Git is deleted,
      then it is completely lost, not just the last changes.  Very
      dangerous.

    - ~trash~ Instead of deleting a file it can also be move to the
      system trash.  Obviously much less dangerous than deleting it.

      Also see option ~magit-delete-by-moving-to-trash~.

    - ~resurrect~ A deleted file can easily be resurrected by "deleting"
      the deletion, which is done using the same command that was used
      to delete the same file in the first place.

    - ~untrack~ Untracking a file can be undone by tracking it again.
 
-Many commands read a value from the user.  By default this is done
-using the built-in function ~completing-read~, but Magit can instead use
-another completion framework.
    - ~rename~ Renaming a file can easily be undone.

  - Sequences:

    - ~reset-bisect~ Aborting (known to Git as "resetting") a bisect
      operation loses all information collected so far.

    - ~abort-rebase~ Aborting a rebase throws away all already modified
      commits, but it's possible to restore those from the reflog.

    - ~abort-merge~ Aborting a merge throws away all conflict
      resolutions which have already been carried out by the user.

    - ~merge-dirty~ Merging with a dirty worktree can make it hard to go
      back to the state before the merge was initiated.

  - References:

    - ~delete-unmerged-branch~ Once a branch has been deleted, it can
      only be restored using low-level recovery tools provided by Git.
      And even then the reflog is gone.  The user always has to
      confirm the deletion of a branch by accepting the default choice
      (or selecting another branch), but when a branch has not been
      merged yet, also make sure the user is aware of that.

    - ~delete-pr-branch~ When deleting a branch that was created from a
      pull request and if no other branches still exist on that
      remote, then `magit-branch-delete' offers to delete the remote
      as well.  This should be safe because it only happens if no
      other refs exist in the remotes namespace, and you can recreate
      the remote if necessary.

    - ~drop-stashes~ Dropping a stash is dangerous because Git stores
      stashes in the reflog.  Once a stash is removed, there is no
      going back without using low-level recovery tools provided by
      Git.  When a single stash is dropped, then the user always has
      to confirm by accepting the default (or selecting another).
      This action only concerns the deletion of multiple stashes at
      once.

  - Various:

    - ~kill-process~ There seldom is a reason to kill a process.

  - Global settings:

    Instead of adding all of the above symbols to the value of this
    option, you can also set it to the atom `t', which has the same
    effect as adding all of the above symbols.  Doing that most
    certainly is a bad idea, especially because other symbols might be
    added in the future.  So even if you don't want to be asked for
    confirmation for any of these actions, you are still better of
    adding all of the respective symbols individually.

    When ~magit-wip-before-change-mode~ is enabled, then the following
    actions can be undone fairly easily: ~discard~, ~reverse~,
    ~stage-all-changes~, and ~unstage-all-changes~.  If and only if
    this mode is enabled, then ~safe-with-wip~ has the same effect as
    adding all of these symbols individually.

*** Completion and Confirmation

Many Magit commands ask the user to select from a list of possible
things to act on, while offering the most likely choice as the
default.  For many of these commands the default is the thing at
point, provided that it actually is a valid thing to act on.  For
many commands that act on a branch, the current branch serves as
the default if there is no branch at point.

These commands combine asking for confirmation and asking for a target
to act on into a single action.  The user can confirm the default
target using ~RET~ or abort using ~C-g~.  This is similar to a ~y-or-n-p~
prompt, but the keys to confirm or abort differ.

At the same time the user is also given the opportunity to select
another target, which is useful because for some commands and/or in
some situations you might want to select the action before selecting
the target by moving to it.

However you might find that for some commands you always want to use
the default target, if any, or even that you want the command to act
on the default without requiring any confirmation at all.  The option
~magit-dwim-selection~ can be used to configure certain commands to that
effect.

Note that when the region is active then many commands act on the
things that are selected using a mechanism based on the region, in
many cases after asking for confirmation.  This region-based mechanism
is called the "selection" and is described in detail in the next
section.  When a selection exists that is valid for the invoked
command, then that command never offers to act on something else, and
whether it asks for confirmation is not controlled by this option.

Also note that Magit asks for confirmation of certain actions that are
not coupled with completion (or the selection).  Such dialogs are also
not affected by this option and are described in the previous section.

- User Option: magit-dwim-selection

This option can be used to tell certain commands to use the thing
at point instead of asking the user to select a candidate to act
on, with or without confirmation.

The value has the form ~((COMMAND nil|PROMPT DEFAULT)...)~.

- COMMAND is the command that should not prompt for a choice.
  To have an effect, the command has to use the function
  ~magit-completing-read~ or a utility function which in turn uses
  that function.

- If the command uses ~magit-completing-read~ multiple times, then
  PROMPT can be used to only affect one of these uses.  PROMPT, if
  non-nil, is a regular expression that is used to match against
  the PROMPT argument passed to ~magit-completing-read~.

- DEFAULT specifies how to use the default.  If it is ~t~, then
  the DEFAULT argument passed to ~magit-completing-read~ is used
  without confirmation.  If it is ~ask~, then the user is given
  a chance to abort.  DEFAULT can also be ~nil~, in which case the
  entry has no effect.

*** The Selection

If the region is active, then many Magit commands act on the things
that are selected using a mechanism based on the region instead of one
single thing.  When the region is not active, then these commands act
on the thing at point or read a single thing to act on.  This is
described in the previous section ¡ª this section only covers how
multiple things are selected, how that is visualized, and how certain
commands behave when that is the case.

Magit's mechanism for selecting multiple things, or rather sections
that represent these things, is based on the Emacs region, but the
area that Magit considers to be selected is typically larger than the
region and additional restrictions apply.

Magit makes a distinction between a region that qualifies as forming a
valid Magit selection and a region that does not.  If the region does
not qualify, then it is displayed as it is in other Emacs buffers.  If
the region does qualify as a Magit selection, then the selection is
always visualized, while the region itself is only visualized if it
begins and ends on the same line.

For a region to qualify as a Magit selection, it must begin in the
heading of one section and end in the heading of a sibling section.
Note that if the end of the region is at the very beginning of section
heading (i.e. at the very beginning of a line) then that section is
considered to be *inside* the selection.

This is not consistent with how the region is normally treated in
Emacs ¡ª if the region ends at the beginning of a line, then that line
is outside the region.  Due to how Magit visualizes the selection, it
should be obvious that this difference exists.

Not every command acts on every valid selection.  Some commands do not
even consider the location of point, others may act on the section at
point but not support acting on the selection, and even commands that
do support the selection of course only do so if it selects things
that they can act on.

This is the main reason why the selection must include the section at
point.  Even if a selection exists, the invoked command may disregard
it, in which case it may act on the current section only.  It is much
safer to only act on the current section but not the other selected
sections than it is to act on the current section *instead* of the
selected sections.  The latter would be much more surprising and if
the current section always is part of the selection, then that cannot
happen.

- Variable: magit-keep-region-overlay

  This variable controls whether the region is visualized as usual
  even when a valid Magit selection or a hunk-internal region exists.
  See the doc-string for more information.

*** The hunk-internal region

Somewhat related to the Magit selection described in the previous
section is the hunk-internal region.

Like the selection, the hunk-internal region is based on the Emacs
region but causes that region to not be visualized as it would in
other Emacs buffers, and includes the line on which the region ends
even if it ends at the very beginning of that line.

Unlike the selection, which is based on a region that must begin in
the heading of one section and ends in the section of a sibling
section, the hunk-internal region must begin inside the *body* of a
hunk section and end in the body of the *same* section.

The hunk-internal region is honored by "apply" commands, which can,
among other targets, act on a hunk.  If the hunk-internal region is
active, then such commands act only on the marked part of the hunk
instead of on the complete hunk.

*** Support for Completion Frameworks

The built-in option ~completing-read-function~ specifies the low-level
function used by ~completing-read~ to ask a user to select from a list
of choices.  Its default value is ~completing-read-default~.
Alternative completion frameworks typically activate themselves by
substituting their own implementation.

Mostly for historic reasons Magit provides a similar option named
~magit-completing-read-function~, which only controls the low-level
function used by ~magit-completing-read~.  This option also makes it
possible to use a different completing mechanism for Magit than for
the rest of Emacs, but doing that is not recommend.

You most likely don't have to customize the magit-specific option to
use an alternative completion framework.  For example, if you enable
~ivy-mode~, then Magit will respect that, and if you enable ~helm-mode~,
then you are done too.

However if you want to use Ido, then ~ido-mode~ won't do the trick.  You
will also have to install the ~ido-completing-read+~ package and use
~magit-ido-completing-read~ as ~magit-completing-read-function~.
 
 - User Option: magit-completing-read-function
 
-  The value of this variable is the function used to perform
-  completion.  Because functions /intended/ to replace ~completing-read~
-  often are not fully compatible drop-in replacements, and also
-  because Magit expects them to add the default choice to the prompt
-  themselves, such functions should not be used directly.  Instead a
-  wrapper function has to be used.
  The value of this variable is the low-level function used to perform
  completion by code that uses ~magit-completing-read~ (as opposed to
  the built-in ~completing-read~).

  The default value, ~magit-builtin-completing-read~, is suitable for
  the standard completion mechanism, ~ivy-mode~, and ~helm-mode~ at least.
 
-Currently only the real ~completing-read~ and [[http://www.emacswiki.org/emacs/InteractivelyDoThings][Ido]] are fully supported.
-More frameworks will be supported in the future.
  The built-in ~completing-read~ and ~completing-read-default~ are *not*
  suitable to be used here.  ~magit-builtin-completing-read~ performs
  some additional work, and any function used in its place has to do
  the same.
 
 - Function: magit-builtin-completing-read prompt choices &optional predicate require-match initial-input hist def
 
-  Perform completion using ~completion-read~.
  This function performs completion using the built-in ~completion-read~
  and does some additional magit-specific work.
 
 - Function: magit-ido-completing-read prompt choices &optional predicate require-match initial-input hist def
 
-  Perform completion using ~ido-completing-read+~ from the package by
-  the same name (which you have to explicitly install).  Ido itself
-  comes with a supposed drop-in replacement ~ido-completing-read~, but
-  that has too many deficits to serve our needs.
  This function performs completion using ~ido-completing-read+~ from the
  package by the same name (which you have to explicitly install) and
  does some additional magit-specific work.
 
-By default many commands that could potentially lead to data loss have
-to be confirmed.  This includes many very common commands, so this
-can become annoying quickly.  Many of these actions can be undone,
-provided ~magit-wip-before-change-mode~ is turned on (which it is not by
-default, due to performance concerns).
  We have to use ~ido-completing-read+~ instead of the
  ~ido-completing-read~ that comes with Ido itself, because the latter,
  while intended as a drop-in replacement, cannot serve that purpose
  because it violates too many of the implicit conventions.
 
-- User Option: magit-no-confirm
- Function: magit-completing-read prompt choices &optional predicate require-match initial-input hist def fallback
 
-  The value of this option is a list of symbols, representing commands
-  which do not have to be confirmed by the user before being carried
-  out.
  This is the function that Magit commands use when they need the user
  to select a single thing to act on.  The arguments have the same
  meaning as for ~completing-read~, except for FALLBACK, which is unique
  to this function and is described below.
 
-  When the global mode ~magit-wip-before-change-mode~ is enabled then
-  many commands can be undone.  If that mode is enabled then adding
-  ~safe-with-wip~ to this list has the same effect as adding ~discard~,
-  ~reverse~, ~stage-all-changes~, and ~unstage-all-changes~.
  Instead of asking the user to choose from a list of possible
  candidates, this function may just return the default specified by
  DEF, with or without requiring user confirmation.  Whether that is
  the case depends on PROMPT, ~this-command~ and ~magit-dwim-selection~.
  See the documentation of the latter for more information.
 
-  #+BEGIN_SRC emacs-lisp
-    (add-to-list 'magit-no-confirm 'safe-with-wip)
-  #+END_SRC
  If it does read a value in the minibuffer, then this function acts
  similar to ~completing-read~, except for the following:
 
-  For a list of all symbols that can be added to the value of this
-  variable, see the doc-string.
  - If REQUIRE-MATCH is ~nil~ and the user exits without a choice, then
    ~nil~ is returned instead of an empty string.
 
-Note that there are commands that ignore this option and always
-require confirmation, or which can be told not to do so using another
-dedicated option.  Also most commands, when acting on multiple sections
-at once always, require confirmation, even when they do respect this
-option when acting on a single section.
  - If REQUIRE-MATCH is non-nil and the users exits without a choice,
    an user-error is raised.

  - FALLBACK specifies a secondary default that is only used if the
    primary default DEF is ~nil~.  The secondary default is not subject
    to ~magit-dwim-selection~ ¡ª if DEF is ~nil~ but FALLBACK is not, then
    this function always asks the user to choose a candidate, just as
    if both defaults were ~nil~.

  - ": " is appended to PROMPT.

  - PROMPT is modified to end with \" (default DEF|FALLBACK): \"
    provided that DEF or FALLBACK is non-nil, that neither ~ivy-mode~
    nor ~helm-mode~ is enabled, and that
    ~magit-completing-read-function~ is set to its default value of
    ~magit-builtin-completing-read~.

*** Additional Completion Options

- User Option: magit-list-refs-sortby

  For many commands that read a ref or refs from the user, the value
  of this option can be used to control the order of the refs.  Valid
  values include any key accepted by the ~--sort~ flag of ~git
  for-each-ref~.  By default, refs are sorted alphabetically by their
  full name (e.g., "refs/heads/master").
 
 ** Running Git
 *** Viewing Git Output
 
 Magit runs Git either for side-effects (e.g. when pushing) or to get
-some value (e.g. the name of the current branch).  When Git is run for
-side-effects then the output goes into a per-repository log buffer,
-which can be consulted when things don't go as expected.
some value (e.g. the name of the current branch).

When Git is run for side-effects, the process output is logged in a
per-repository log buffer, which can be consulted using the
~magit-process~ command when things don't go as expected.

The output/errors for up to `magit-process-log-max' Git commands are
retained.
 
 - Key: $, magit-process
 
@@ -1247,6 +1587,26 @@ sections are available.  There is one additional command.
   in the process buffer.  This is useful when debugging, otherwise it
   just negatively affects performance.
 
*** Git Process Status

When a Git process is running for side-effects, Magit displays an
indicator in the mode line, using the ~magit-mode-line-process~ face.

If the Git process exits successfully, the process indicator is
removed from the mode line immediately.

In the case of a Git error, the process indicator is not removed, but
is instead highlighted with the ~magit-mode-line-process-error~ face,
and the error details from the process buffer are provided as a
tooltip for mouse users.  This error indicator persists in the mode
line until the next magit buffer refresh.

If you do not wish process errors to be indicated in the mode line,
customize the ~magit-process-display-mode-line-error~ user option.

Process errors are additionally indicated at the top of the status
buffer.

 *** Running Git Manually
 
 While Magit provides many Emacs commands to interact with Git, it does
@@ -1259,32 +1619,38 @@ switch to a shell.
 
   Shows the popup buffer featuring the below suffix commands.
 
-These suffix commands run a Git subcommand.  The user input has to
-begin with the subcommand, "git" is assumed.
-
 - Key: ! !, magit-git-command-topdir
 
-  This command reads a Git subcommand from the user and executes it in
-  the top-level directory of the current repository.
  This command reads a command from the user and executes it in the
  top-level directory of the current working tree.

  The string "git " is used as initial input when prompting the user
  for the command.  It can be removed to run another command.
 
 - Key: ! p, magit-git-command
 
-  This command reads a Git subcommand from the user and executes it in
  This command reads a command from the user and executes it in
   ~default-directory~.  With a prefix argument the command is executed
-  in the top-level directory of the current repository instead.
  in the top-level directory of the current working tree instead.
 
-These suffix commands run arbitrary shell commands.
  The string "git " is used as initial input when prompting the user
  for the command.  It can be removed to run another command.
 
 - Key: ! s, magit-shell-command-topdir
 
-  This command reads a shell command from the user and executes it in
-  the top-level directory of the current repository.
  This command reads a command from the user and executes it in the
  top-level directory of the current working tree.
 
 - Key: ! S, magit-shell-command
 
-  This command reads a shell command from the user and executes it in
  This command reads a command from the user and executes it in
   ~default-directory~.  With a prefix argument the command is executed
-  in the top-level directory of the current repository instead.
  in the top-level directory of the current working tree instead.

- User Option: magit-shell-command-verbose-prompt

  Whether the prompt, used by the the above commands when reading a
  shell command, shows the directory in which it will be run.
 
 These suffix commands start external gui tools.
 
@@ -1319,8 +1685,9 @@ one you think you are using.
 
 - Key: M-x magit-version, magit-version
 
-  Shows the currently used versions of Magit, Git, and Emacs in the
-  echo area.  Non-interactively this just returns the Magit version.
  This command shows the currently used versions of Magit, Git, and
  Emacs in the echo area.  Non-interactively this just returns the
  Magit version.
 
 When the ~system-type~ is ~windows-nt~, then ~magit-git-executable~ is set
 to an absolute path when Magit is first loaded.  This is necessary
@@ -1329,11 +1696,13 @@ the actual git binary, which are also placed on ~$PATH~, and using one
 of these wrappers instead of the binary would degrade performance
 horribly.
 
-If Magit doesn't find the correct executable then you *can* work around
-that by setting ~magit-git-executable~ to an absolute path.  But note
-that doing so is a kludge.  It is better to make sure the order in the
-environment variable ~$PATH~ is correct, and that Emacs is started with
-that environment in effect.  If you have to connect from Windows to a
If Magit doesn't find the correct executable then you *can* work
around that by setting ~magit-git-executable~ to an absolute path.
But note that doing so is a kludge.  It is better to make sure the
order in the environment variable ~$PATH~ is correct, and that Emacs
is started with that environment in effect.  The command
~magit-debug-git-executable~ can be useful to find out where Emacs is
searching for git.  If you have to connect from Windows to a
 non-Windows machine, then you must change the value to "git".
 
 - User Option: magit-git-executable
@@ -1342,6 +1711,10 @@ non-Windows machine, then you must change the value to "git".
   executable or the string "git" to let Emacs find the executable
   itself, using the standard mechanism for doing such things.
 
- Key: M-x magit-debug-git-executable, magit-debug-git-executable

  Display a buffer with information about ~magit-git-executable~.

 *** Global Git Arguments
 
 - User Option: magit-git-global-arguments
@@ -1358,6 +1731,7 @@ non-Windows machine, then you must change the value to "git".
   used every time Magit runs Git for any purpose.
 
 * Inspecting
** _ :ignore:
 
 The functionality provided by Magit can be roughly divided into three
 groups: inspecting existing data, manipulating existing data or adding
@@ -1376,6 +1750,7 @@ mainly concerned with the porcelain -- Magit's plumbing layer is
 described later.
 
 ** Status Buffer
*** _ :ignore:
 
 While other Magit buffers contain e.g. one particular diff or one
 particular log, the status buffer contains the diffs for staged and
@@ -1559,39 +1934,6 @@ The following functions can also be added to the above hook:
   ~magit-insert-unpulled-or-recent-commits~ (provided there are no
   unpulled commits) show.
 
-- Function: magit-insert-modules-unpulled-from-upstream
-
-  Insert sections for modules that haven't been pulled from the
-  upstream yet.  These sections can be expanded to show the respective
-  commits.
-
-- Function: magit-insert-modules-unpulled-from-pushremote
-
-  Insert sections for modules that haven't been pulled from the
-  push-remote yet.  These sections can be expanded to show the
-  respective commits.
-
-- Function: magit-insert-modules-unpushed-to-upstream
-
-  Insert sections for modules that haven't been pushed to the upstream
-  yet.  These sections can be expanded to show the respective commits.
-
-- Function: magit-insert-modules-unpushed-to-pushremote
-
-  Insert sections for modules that haven't been pushed to the
-  push-remote yet. These sections can be expanded to show the
-  respective commits.
-
-- Function: magit-insert-submodules
-
-  Insert sections for all submodules.  For each section insert the
-  path, the branch, and the output of ~git describe --tags~.
-
-  Press ~RET~ on such a submodule section to show its own status buffer.
-  Press ~RET~ on the "Modules" section to display a list of submodules
-  in a separate buffer.  This shows additional information not
-  displayed in the super-repository's status buffer.
-
 - Function: magit-insert-unpulled-cherries
 
   Insert section showing unpulled commits.
@@ -1614,7 +1956,8 @@ used here.
 *** Status Header Sections
 
 The contents of status buffers is controlled using the hook
-~magit-status-sections-hook~, as described in the previous section.
~magit-status-sections-hook~ (see [[*Status Sections]]).

 By default ~magit-insert-status-headers~ is the first member of that
 hook variable.
 
@@ -1663,7 +2006,8 @@ By default the following functions are members of the above hook:
 
 - Function: magit-insert-tags-header
 
-  Insert a header line about the current and/or next tag.
  Insert a header line about the current and/or next tag, along with
  the number of commits between the tag and ~HEAD~.
 
 The following functions can also be added to the above hook:
 
@@ -1683,6 +2027,69 @@ The following functions can also be added to the above hook:
 
   Insert a header line about the current user.
 
*** Status Module Sections

The contents of status buffers is controlled using the hook
~magit-status-sections-hook~ (see [[*Status Sections]]).

By default ~magit-insert-modules~ is /not/ a member of that hook
variable.

- Function: magit-insert-modules

  Insert submodule sections.

  Hook ~magit-module-sections-hook~ controls which module sections are
  inserted, and option ~magit-module-sections-nested~ controls whether
  they are wrapped in an additional section.

- Option: magit-module-sections-hook

  Hook run by ~magit-insert-modules~.

- Option: magit-module-sections-nested

  This option controls whether ~magit-insert-modules~ wraps inserted
  sections in an additional section.

  If this is non-nil, then only a single top-level section is inserted.
  If it is nil, then all sections listed in ~magit-module-sections-hook~
  become top-level sections.

- Function: magit-insert-modules-overview

  Insert sections for all submodules.  For each section insert the
  path, the branch, and the output of ~git describe --tags~,
  or, failing that, the abbreviated HEAD commit hash.

  Press ~RET~ on such a submodule section to show its own status buffer.
  Press ~RET~ on the "Modules" section to display a list of submodules
  in a separate buffer.  This shows additional information not
  displayed in the super-repository's status buffer.

- Function: magit-insert-modules-unpulled-from-upstream

  Insert sections for modules that haven't been pulled from the
  upstream yet.  These sections can be expanded to show the respective
  commits.

- Function: magit-insert-modules-unpulled-from-pushremote

  Insert sections for modules that haven't been pulled from the
  push-remote yet.  These sections can be expanded to show the
  respective commits.

- Function: magit-insert-modules-unpushed-to-upstream

  Insert sections for modules that haven't been pushed to the upstream
  yet.  These sections can be expanded to show the respective commits.

- Function: magit-insert-modules-unpushed-to-pushremote

  Insert sections for modules that haven't been pushed to the
  push-remote yet.  These sections can be expanded to show the
  respective commits.

 *** Status Options
 
 - User Option: magit-status-refresh-hook
@@ -1780,6 +2187,7 @@ The following functions can be added to the above option:
   but not its push branch.
 
 ** Logging
*** _ :ignore:
 
 The status buffer contains logs for the unpushed and unpulled commits,
 but that obviously isn't enough.  The prefix command ~magit-log-popup~,
@@ -1787,11 +2195,11 @@ on ~l~, features several suffix commands, which show a specific log in a
 separate log buffer.
 
 Like other popups, the log popup also features several arguments that
-can be changed before invoking one of the suffix commands.  However in
-case of the log popup these arguments correspond to those currently in
-use in the current repository's log buffer.  When the log popup is
-invoked while no log buffer exists for the current repository yet,
-then the default value of ~magit-log-arguments~ is used instead.
can be changed before invoking one of the suffix commands.  However,
in the case of the log popup, these arguments may be taken from those
currently in use in the current repository's log buffer, depending on
the value of ~magit-use-sticky-arguments~ (see [[*Popup Buffers and
Prefix Commands]]).
 
 For information about the various arguments, see [[man:git-log]]
 The switch ~++order=VALUE~ is converted to one of ~--author-date-order~,
@@ -1933,7 +2341,7 @@ the status buffer.
 
   Double the number of commits the current log buffer is limited to.
 
-- Key: =, magit-log-half-commit-limit
- Key: -, magit-log-half-commit-limit
 
   Half the number of commits the current log buffer is limited to.
 
@@ -1948,6 +2356,34 @@ the status buffer.
   Whether to show the refnames after the commit summaries.  This is
   useful if you use really long branch names.
 
Magit displays references in logs a bit differently from how Git does
it.

Local branches are blue and remote branches are green.  Of course that
depends on the used theme, as do the colors used for other types of
references.  The current branch has a box around it, as do remote
branches that are their respective remote's ~HEAD~ branch.

If a local branch and its push-target point at the same commit, then
their names are combined to preserve space and to make that
relationship visible.  For example:

#+BEGIN_EXAMPLE
  origin/feature
  [green][blue-]

  instead of

  feature origin/feature
  [blue-] [green-------]
#+END_EXAMPLE

Also note that while the popup features the ~--show-signature~ argument,
that won't actually be used when enabled, because Magit defaults to
use just one line per commit.  Instead the commit colorized to
indicate the validity of the signed commit object, using the faces
named ~magit-signature-*~ (which see).

 For a description of ~magit-log-margin~ see [[*Log Margin]].
 
 *** Log Margin
@@ -2127,6 +2563,7 @@ Also see [[man:git-reflog]]
     is shown, then this specifies how much space is used to do so.
 
 ** Diffing
*** _ :ignore:
 
 The status buffer contains diffs for the staged and unstaged commits,
 but that obviously isn't enough.  The prefix command ~magit-diff-popup~,
@@ -2134,11 +2571,11 @@ on ~d~, features several suffix commands, which show a specific diff in
 a separate diff buffer.
 
 Like other popups, the diff popup also features several arguments that
-can be changed before invoking one of the suffix commands.  However in
-case of the diff popup these arguments correspond to those currently
-in use in the current repository's diff buffer.  When the diff popup
-is invoked while no diff buffer exists for the current repository yet,
-then the default value of ~magit-diff-arguments~ is used instead.
can be changed before invoking one of the suffix commands.  However,
in the case of the diff popup, these arguments may be taken from those
currently in use in the current repository's log buffer, depending on
the value of ~magit-use-sticky-arguments~ (see [[*Popup Buffers and
Prefix Commands]]).
 
 Also see [[man:git-diff]]
 
@@ -2157,7 +2594,7 @@ Also see [[man:git-diff]]
 
   RANGE should be a range (A..B or A...B) but can also be a single
   commit.  If one side of the range is omitted, then it defaults to
-  HEAD.  If just a commit is given, then changes in the working tree
  ~HEAD~.  If just a commit is given, then changes in the working tree
   relative to that commit are shown.
 
   If the region is active, use the revisions on the first and last
@@ -2165,7 +2602,7 @@ Also see [[man:git-diff]]
   revisions, choose a revision to view changes along, starting at the
   common ancestor of both revisions (i.e., use a "..."  range).
 
-- Key: d w, magit-diff-worktree
- Key: d w, magit-diff-working-tree
 
   Show changes between the current working tree and the ~HEAD~ commit.
   With a prefix argument show changes between the working tree and a
@@ -2247,6 +2684,16 @@ in the status buffer.
   This command swaps revisions in the diff range from "revA..revB"
   to "revB..revA", or vice versa.
 
- Key: D F, magit-diff-toggle-file-filter

  This command toggles the file restriction of the diffs in the
  current buffer, allowing you to quickly switch between viewing all
  the changes in the commit and the restricted subset.  As a special
  case, when this command is called from a log buffer, it toggles the
  file restriction in the repository's revision buffer, which is
  useful when you display a revision from a log buffer that is
  restricted to a file or files.

 In addition to the above popup, which allows changing any of the
 supported arguments, there also exist some commands which change a
 particular argument.
@@ -2327,9 +2774,13 @@ without having to using one of the diff popups.
   hunk headers get less useful the "older" the changes are, and as a
   result, jumping to the appropriate position gets less reliable.
 
-  Also see ~magit-diff-visit-file-worktree~, which visits the respective
-  blob, unless the diff shows changes in the worktree, the index, or
-  ~HEAD~.
  Also see ~magit-diff-visit-file~, which visits the respective blob,
  unless the diff shows changes in the worktree, the index, or ~HEAD~.

- Command: magit-diff-visit-file-other-window

  From a diff, visit the corresponding file at the appropriate
  position in another window.
 
 - Key: j, magit-jump-to-diffstat-or-diff
 
@@ -2355,6 +2806,28 @@ without having to using one of the diff popups.
   - ~t~ show fine differences for the current diff hunk only.
   - ~all~ show fine differences for all displayed diff hunks.
 
- User Option: magit-diff-adjust-tab-width

  Whether to adjust the width of tabs in diffs.

  Determining the correct width can be expensive if it requires
  opening large and/or many files, so the widths are cached in the
  variable ~magit-diff--tab-width-cache~.  Set that to nil to invalidate
  the cache.

  - ~nil~ Never ajust tab width.  Use `tab-width's value from the Magit
    buffer itself instead.

  - ~t~ If the corresponding file-visiting buffer exits, then use
    ~tab-width~'s value from that buffer.  Doing this is cheap, so this
    value is used even if a corresponding cache entry exists.

  - ~always~ If there is no such buffer, then temporarily visit the file
    to determine the value.

  - NUMBER Like ~always~, but don't visit files larger than NUMBER
    bytes.

 - User Option: magit-diff-paint-whitespace
 
   Specify where to highlight whitespace errors.
@@ -2400,7 +2873,7 @@ without having to using one of the diff popups.
 
   ~magit-diff-highlight-hunk-region-using-overlays~ and
   ~magit-diff-highlight-hunk-region-using-underline~ emphasize the
-  region by placing delimiting horizonal lines before and after it.
  region by placing delimiting horizontal lines before and after it.
   Both of these functions have glitches which cannot be fixed due to
   limitations of Emacs' display engine.  For more information see
   https://github.com/magit/magit/issues/2758 ff.
@@ -2436,12 +2909,44 @@ without having to using one of the diff popups.
   to ~magit-revision-header-format~.
 
   Both cells are regular expressions.  The car specifies where to
-  insert the author gravatar image.  The top halve of the image is
-  inserted right after the matched text, the bottom halve on the
  insert the author gravatar image.  The top half of the image is
  inserted right after the matched text, the bottom half on the
   next line at the same offset.  The cdr specifies where to insert
   the committer image, accordingly.  Either the car or the cdr may
   be nil.
 
- User Option: magit-revision-use-hash-sections

  Whether to turn hashes inside the commit message into sections.

  If non-nil, then hashes inside the commit message are turned into
  ~commit~ sections.  There is a trade off to be made between
  performance and reliability:

  - ~slow~ calls git for every word to be absolutely sure.
  - ~quick~ skips words less than seven characters long.
  - ~quicker~ additionally skips words that don't contain a number.
  - ~quickest~ uses all words that are at least seven characters long
    and which contain at least one number as well as at least one
    letter.

  If nil, then no hashes are turned into sections, but you can still
  visit the commit at point using "RET".

The diffs shown in the revision buffer may be automatically restricted
to a subset of the changed files.  If the revision buffer is displayed
from a log buffer, the revision buffer will share the same file
restriction as that log buffer (also see the command
~magit-diff-toggle-file-filter~).  Note, however, that the log's file
restriction will be ignored when ~magit-log-arguments~ includes
~--follow~.  In this case, the ~-u~ argument of the log popup can be
used to show the file-restricted diffs inline.

If the revision buffer is not displayed from a log buffer, the file
restriction is determined by the file restriction in the repository's
diff buffer, if it exists, and the value of the option
~magit-use-sticky-arguments~.

 ** Ediffing
 
 This section describes how to enter Ediff from Magit buffers.  For
@@ -2501,7 +3006,7 @@ information on how to use Ediff itself, see info:ediff.
 
 - Key: E w, magit-ediff-show-working-tree
 
-  Show changes in a file between HEAD and working tree using Ediff.
  Show changes in a file between ~HEAD~ and working tree using Ediff.
 
 - Key: E c, magit-ediff-show-commit
 
@@ -2537,6 +3042,7 @@ information on how to use Ediff itself, see info:ediff.
   that were created using a Magit command.
 
 ** References Buffer
*** _ :ignore:
 
 - Key: y, magit-show-refs-popup
 
@@ -2801,100 +3307,126 @@ bisect session.
 
 Also see [[man:git-blame]]
 
To start blaming use ~M-x~ in a file-visiting buffer to invoke one of
the next tree commands.  In a blob-visiting buffer you can also use
the key bindings described below, and when Magit-File mode is enabled,
then you can at least use ~C-c M-g~ to enter the blaming popup instead
of having to type out the command name.

 - Key: M-x magit-blame, magit-blame
 
-  Display edit history of FILE up to REVISION.
  This command augments each line or chunk of lines in the current
  file- or blob-visiting buffer with information about what commits
  last touched these lines.

  If the buffer visits a revision of that file, then history up to
  that revision is considered.  Otherwise, the file's full history is
  considered, including uncommitted changes.

  If Magit-Blame mode is already turned on in the current buffer then
  blaming is done recursively, by visiting REVISION:FILE (using
  ~magit-find-file~), where REVISION is the revision before the revision
  that added the current line or chunk of lines.
 
-  Interactively blame the file being visited in the current buffer.
-  If the buffer visits a revision of that file, then blame up to that
-  revision.  Otherwise, blame the file's full history, including
-  uncommitted changes.
- Key: M-x magit-blame-reverse, magit-blame-reverse
 
-  If Magit-Blame mode is already turned on then blame recursively, by
-  visiting REVISION:FILE (using ~magit-find-file~), where revision is
-  the revision before the revision that added the lines at point.
  This command augments each line or chunk of lines in the current
  file- or blob-visiting buffer with information about the last
  revision in which a line still existed.
 
-  ARGS is a list of additional arguments to pass to ~git blame~; only
-  arguments available from ~magit-blame-popup~ should be used.
  Like ~magit-blame~, this command can be used recursively.
 
 - Key: M-x magit-blame-popup, magit-blame-popup
 
   This prefix command shows the above suffix command along with the
   appropriate infix arguments in a popup buffer.
 
The above commands are also bound in the keymaps ~magit-blame-mode-map~
and ~magit-blob-mode-map~, and in the popup ~magit-file-popup~.  Once
Magit-Blame mode is enabled in a file-visiting buffer, you can use ~B~
to show the blaming popup, ~b~ to blame recursively going backward in
time, and ~f~ to blame recursively going forward in time (i.e. blame in
reverse).  These bindings are always available in blob-visiting
buffers.

Additionally the following key bindings are available when Magit-Blame
mode is enabled.  These commands are also available in other buffers;
here only the behavior is described that is relevant in file-visiting
buffers that are being blamed.

 - Key: RET, magit-show-commit
 
-  Show the commit at point.  If there is no commit at point or with a
-  prefix argument, prompt for a commit.
  This command shows the commit that last touched the line at point.
 
 - Key: SPC, magit-diff-show-or-scroll-up
 
-  Update the commit or diff buffer for the thing at point.
  This command updates the commit buffer.
 
-  Either show the commit or stash at point in the appropriate buffer,
-  or if that buffer is already being displayed in the current frame
-  and contains information about that commit or stash, then instead
-  scroll the buffer up.  If there is no commit or stash at point, then
-  prompt for a commit.
  This either shows the commit that last touched the line at point in
  the appropriate buffer, or if that buffer is already being displayed
  in the current frame and if that buffer contains information about
  that commit, then the buffer is scrolled up instead.
 
 - Key: DEL, magit-diff-show-or-scroll-down
 
-  Update the commit or diff buffer for the thing at point.
  This command updates the commit buffer.
 
-  Either show the commit or stash at point in the appropriate buffer,
-  or if that buffer is already being displayed in the current frame
-  and contains information about that commit or stash, then instead
-  scroll the buffer down.  If there is no commit or stash at point,
-  then prompt for a commit.
  This either shows the commit that last touched the line at point in
  the appropriate buffer, or if that buffer is already being displayed
  in the current frame and if that buffer contains information about
  that commit, then the buffer is scrolled down instead.
 
 - Key: n, magit-blame-next-chunk
 
-  Move to the next chunk.
  This command moves to the next chunk.
 
 - Key: N, magit-blame-next-chunk-same-commit
 
-  Move to the next chunk from the same commit.
  This command moves to the next chunk from the same commit.
 
 - Key: p, magit-blame-previous-chunk
 
-  Move to the previous chunk.
  This command moves to the previous chunk.
 
 - Key: P, magit-blame-previous-chunk-same-commit
 
-  Move to the previous chunk from the same commit.
  This command moves to the previous chunk from the same commit.
 
 - Key: q, magit-blame-quit
 
-  Turn off Magit-Blame mode.  If the buffer was created during a
-  recursive blame, then also kill the buffer.
  This command turns off Magit-Blame mode.  If the buffer was created
  during a recursive blame, then it also kills the buffer.
 
 - Key: M-w, magit-blame-copy-hash
 
-  Save the hash of the current chunk's commit to the kill ring.
  This command saves the hash of the current chunk's commit to the
  kill ring.
 
-  When the region is active, then save that to the ~kill-ring~,
-  like ~kill-ring-save~ would.
  When the region is active, the command saves the region's content
  instead of the hash, like ~kill-ring-save~ would.
 
 - Key: t, magit-blame-toggle-headings
 
-  Show or hide blame chunk headings.
  This command shows or hides blame chunk headings.
 
 - User Option: magit-blame-heading-format
 
-  Format string used for blame headings.
  The format string used for blame headings.
 
 - User Option: magit-blame-time-format
 
-  Format string used for time strings in blame headings.
  The format string used for time strings in blame headings.
 
 - User Option: magit-blame-show-headings
 
-  Whether to initially show blame block headings.  The headings can
-  also be toggled locally using command ~magit-blame-toggle-headings~.
  This option controls whether blame block headings are initially
  shown.  The headings can also be toggled locally using the command
  ~magit-blame-toggle-headings~.
 
 - User Option: magit-blame-goto-chunk-hook
 
-  Hook run by ~magit-blame-next-chunk~ and ~magit-blame-previous-chunk~.
  This hook is run by ~magit-blame-next-chunk~ and
  ~magit-blame-previous-chunk~.
 
 * Manipulating
 ** Repository Setup
@@ -2924,6 +3456,7 @@ Also see [[man:git-blame]]
   then ask the user every time she clones a repository.
 
 ** Staging and Unstaging
*** _ :ignore:
 
 Like Git, Magit can of course stage and unstage complete files.
 Unlike Git, it also allows users to gracefully un-/stage
@@ -3080,6 +3613,7 @@ With a prefix argument all apply variants attempt a 3-way merge when
 appropriate (i.e. when ~git apply~ is used internally).
 
 ** Committing
*** _ :ignore:
 
 When the user initiates a commit, Magit calls ~git commit~ without any
 arguments, so Git has to get it from the user.  It creates the file
@@ -3211,7 +3745,7 @@ stored at the beginning and the end of an edit session (regardless of
 whether the session is finished successfully or was canceled).  It is
 sometimes useful to bring back messages from that ring.
 
-- Key: C-s M-s, git-commit-save-message
- Key: C-c M-s, git-commit-save-message
 
   Save the current buffer content to the commit message ring.
 
@@ -3499,9 +4033,17 @@ features are available from separate popups.
   Whether the ~magit-branch-popup~ shows Git variables.  This defaults
   to t to avoid changing key bindings.  When set to nil, no variables
   are displayed directly in this popup, and the sub-popup
-  ~magit-branch-config-popup~ has to be used indead to view and change
  ~magit-branch-config-popup~ has to be used instead to view and change
   branch related variables.
 
- Key: b C, magit-branch-config-popup

  This command shows branch related variables in a separate popup.  By
  default this asks the user for which branch the variables should be
  shown.  When ~magit-branch-popup-show-variables~ is ~nil~, then it shows
  the variables for the current branch, unless a prefix argument is
  used.

 - Key: b b, magit-checkout
 
   Checkout a revision read in the minibuffer and defaulting to the
@@ -3527,6 +4069,28 @@ features are available from separate popups.
 
   Also see option ~magit-branch-prefer-remote-upstream~.
 
- Key: b l, magit-branch-checkout

  This command checks out an existing or new local branch.  It reads a
  branch name from the user offering all local branches and a subset
  of remote branches as candidates.  Remote branches for which a local
  branch by the same name exists are omitted from the list of
  candidates.  The user can also enter a completely new branch name.

  - If the user selects an existing local branch, then that is checked
    out.

  - If the user selects a remote branch, then it creates and checks
    out a new local branch with the same name, and configures the
    selected remote branch as the push target.

  - If the user enters a new branch name, then it creates and checks
    that out, after also reading the starting-point from the user.

  In the latter two cases the upstream is also set.  Whether it is set
  to the chosen starting point or something else depends on the value
  of ~magit-branch-adjust-remote-upstream-alist~.

 - Key: b s, magit-branch-spinoff
 
   This command creates and checks out a new branch starting at and
@@ -3549,14 +4113,112 @@ features are available from separate popups.
   upstream.  Interactively, FROM is only ever non-nil, if the
   region selects some commits, and among those commits, FROM is
   the commit that is the fewest commits ahead of the source
-  branch.  (It not yet possible to spin off a single commit,
-  unless it is the only unpushed commit.  See #2920.)
  branch.
 
   The commit at the other end of the selection actually does not
   matter, all commits between FROM and ~HEAD~ are moved to the new
   branch.  If FROM is not reachable from ~HEAD~ or is reachable from the
   source branch's upstream, then an error is raised.
 
- Key: b R, magit-branch-pull-request

  This command creates and configures a new branch from a Github
  pull-request, creating and configuring a new remote if necessary.

  The name of the local branch is the same as the name of the remote
  branch that you are being asked to merge, unless the contributor
  could not be bother to properly name the branch before opening the
  pull-request.  The most likely such case is when you are being asked
  to merge something like "fork/master" into "origin/master".  In such
  cases the local branch will be named "pr-N", where ~N~ is the
  pull-request number.

  These variables are always set by this command:

  - ~branch.<name>.pullRequest~ is set to the pull-request number.
  - ~branch.<name>.description~ is set to the pull-request title.
  - ~branch.<name>.rebase~ is set to ~true~ because there should be no
    merge commits among the commits in a pull-request.

  This command also configures the upstream and the push-remote of the
  local branch that it creates.

  The branch against which the pull-request was opened, is always used
  as the upstream.  This makes it easy to see what commits you are
  being asked to merge in the section titled something like "Unmerged
  into origin/master".

  Like for other commands that create a branch it depends on the
  option ~magit-branch-prefer-remote-upstream~ whether the remote branch
  itself or the respective local branch is used as the upstream, so
  this section may also be titled e.g. "Unmerged into master".

  When necessary and possible, then the remote pull-request branch is
  configured to be used as the push-target.  This makes it easy to see
  what further changes the contributor has made since you last
  reviewed their changes in the section titled something like
  "Unpulled from origin/new-feature" or "Unpulled from
  fork/new-feature".

  - If the pull-request branch is located in the upstream repository,
    then it is not necessary to configure the push-target.

    (If you have push access to the upstream repository, then it is
    usually a good idea to configure that as the push-remote using
    ~remote.pushDefault~.  However even if you are not using that
    recommended setting, then it is still easy enough to set
    ~branch.<name>.pushRemote~ while pushing using ~P p~.)

  - If the pull-request branch is located inside a fork, then you
    usually are able to push to that branch, because Github by default
    allows the recipient of a pull-request to push to the remote
    pull-request branch even if it is located in a fork.  The
    contributor has to explicitly disable this.

    - If you are not allowed to push to the pull-request branch on
      the fork, then a branch by the same name located in the
      upstream repository is configured as the push-target.

    - A ¡ª sadly rather common ¡ª special case is when the contributor
      didn't bother to use a dedicated branch for the pull-request.

      The most likely such case is when you are being asked to merge
      something like "fork/master" into "origin/master".  The special
      push permission mentioned above is never granted for the branch
      that is the repository's default branch, and that is almost
      certainly be the case in this scenario.

      To enable you to easily push somewhere anyway, the local branch
      is named "pr-N" (where ~N~ is the pull-request number) and the
      upstream repository is used as the push-remote.

    - Finally, if you are allowed to push to the pull-request branch
      and the contributor had the foresight to use a dedicated branch,
      then the fork is configured as the push-remote.

    The push-remote is configured using ~branch.<name>.pushRemote~, even
    if the used value is identical to that of ~remote.pushDefault~, just
    in case you change the value of the latter later on.  Additionally
    the variable ~branch.<name>.pullRequestRemote~ is set to the fork
    remote.

  When you later delete the local pull-request branch, then you are
  offered to also delete the corresponding remote, provided it is not
  the upstream remote and that the tracking branch that corresponds to
  the deleted branch is the only remaining tracked branch.  If you
  don't confirm, then only the tracking branch itself is deleted in
  addition to the local branch.

  Do not delete the tracking branch instead of the local branch.  The
  cleanup mentioned in the previous paragraph is not performed if you
  do that.

- Key: b r, magit-checkout-pull-request

  This command creates and configures a new branch from a pull
  request, the same way ~magit-branch-pull-request~ does.  Additionally
  it checks out the new branch.

 - Key: b x, magit-branch-reset
 
   This command resets a branch, defaulting to the branch at point, to
@@ -3596,23 +4258,22 @@ features are available from separate popups.
   This option specifies whether remote upstreams are favored over
   local upstreams when creating new branches.
 
-  When a new branch is created, Magit offers the branch, commit, or
-  stash as the default starting point of the new branch.  If there is
-  no such thing at point, then it falls back to offer the current
-  branch as starting-point.  The user may then accept that default or
-  pick something else.
  When a new branch is created, then the branch, commit, or stash at
  point is suggested as the starting point of the new branch, or if
  there is no such revision at point the current branch.  In either
  case the user may choose another starting point.
 
-  If the chosen starting-point is a branch, then it may also be set
  If the chosen starting point is a branch, then it may also be set
   as the upstream of the new branch, depending on the value of the
   Git variable `branch.autoSetupMerge'.  By default this is done
   for remote branches, but not for local branches.
 
   You might prefer to always use some remote branch as upstream.
-  If the chosen starting-point is (1) a local branch, (2) whose
  If the chosen starting point is (1) a local branch, (2) whose
   name matches a member of the value of this option, (3) the
   upstream of that local branch is a remote branch with the same
   name, and (4) that remote branch can be fast-forwarded to the
-  local branch, then the chosen branch is used as starting-point,
  local branch, then the chosen branch is used as starting point,
   but its own upstream is used as the upstream of the new branch.
 
   Members of this option's value are treated as branch names that
@@ -3654,7 +4315,7 @@ features are available from separate popups.
   wasteful.  Instead a branch like "maint" or "master" should be used
   as the upstream.
 
-  This option allows specifing the branch that should be used as the
  This option allows specifying the branch that should be used as the
   upstream when branching certain remote branches.  The value is an
   alist of the form ~((UPSTREAM . RULE)...)~.  The first matching
   element is used, the following elements are ignored.
@@ -3694,9 +4355,33 @@ features are available from separate popups.
   This command creates and checks out a new orphan branch with
   contents from a given revision.
 
- Command: magit-branch-or-checkout

  This command is a hybrid between ~magit-checkout~ and
  ~magit-branch-and-checkout~ and is intended as a replacement for the
  former in ~magit-branch-popup~.

  It first asks the user for an existing branch or revision.  If the
  user input actually can be resolved as a branch or revision, then it
  checks that out, just like ~magit-checkout~ would.

  Otherwise it creates and checks out a new branch using the input as
  its name.  Before doing so it reads the starting-point for the new
  branch.  This is similar to what ~magit-branch-and-checkout~ does.

  To use this command instead of ~magit-checkout~ add this to your init
  file:

  #+BEGIN_SRC emacs-lisp
    (magit-remove-popup-key 'magit-branch-popup :action ?b)
    (magit-define-popup-action 'magit-branch-popup
      ?b "Checkout" 'magit-branch-or-checkout
      'magit-branch t)
  #+END_SRC

 *** The Branch Config Popup
 
-- Command: magit-branch-popup
- Command: magit-branch-config-popup
 
   This prefix command shows the following branch-related Git variables
   in a popup buffer.  The values can be changed from that buffer.
@@ -3811,7 +4496,7 @@ values.  If you want to change the global value, which is used when
 the local value is undefined, then you have to do so on the command
 line, e.g.:
 
-#+BEGIN_SRC shell
#+BEGIN_SRC shell-script
   git config --global remote.autoSetupMerge always
 #+END_SRC
 
@@ -3908,13 +4593,13 @@ begin with the strings consisting of six times the same character, one
 of ~<~, ~|~, ~=~ and ~>~ and are followed by information about the source of
 the respective versions, e.g.:
 
-#+BEGIN_SRC undefined
#+BEGIN_EXAMPLE
   <<<<<<< HEAD
   Take the blue pill.
   =======
   Take the red pill.
   >>>>>>> feature
-#+END_SRC
#+END_EXAMPLE
 
 In this case you have chosen to take the red pill on one branch and on
 another you picked the blue pill.  Now that you are merging these two
@@ -3927,22 +4612,22 @@ it in order to bring in the changes from the other side, remove the
 other versions as well as the markers, and then stage the result.  A
 possible resolution might be:
 
-#+BEGIN_SRC undefined
#+BEGIN_EXAMPLE
   Take both pills.
-#+END_SRC
#+END_EXAMPLE
 
 Often it is useful to see not only the two sides of the conflict but
 also the "original" version from before the same area of the file was
 modified twice on different branches.  Instruct Git to insert that
 version as well by running this command once:
 
-#+BEGIN_SRC shell
#+BEGIN_SRC shell-script
   git config --global merge.conflictStyle diff3
 #+END_SRC
 
 The above conflict might then have looked like this:
 
-#+BEGIN_SRC undefined
#+BEGIN_EXAMPLE
   <<<<<<< HEAD
   Take the blue pill.
   ||||||| merged common ancestors
@@ -3950,7 +4635,7 @@ The above conflict might then have looked like this:
   =======
   Take the red pill.
   >>>>>>> feature
-#+END_SRC
#+END_EXAMPLE
 
 If that were the case, then the above conflict resolution would not
 have been correct, which demonstrates why seeing the original version
@@ -3978,7 +4663,7 @@ commands and binding ~C-c ^ C-h~ and press ~RET~ while point is on a
 command name to read its documentation.
 
 Normally you would edit one version and then tell Smerge to keep only
-that version.  Use ~C-c ^ m~ (~smerge-keep-mine)~ to keep the "HEAD"
that version.  Use ~C-c ^ m~ (~smerge-keep-mine~) to keep the ~HEAD~
 version or ~C-c ^ o~ (~smerge-keep-other~) to keep the version that
 follows "|||||||".  Then use ~C-c ^ n~ to move to the next conflicting
 area in the same file.  Once you are done resolving conflicts, return
@@ -3997,9 +4682,10 @@ Ediff is beyond the scope of this manual, instead see info:ediff.
 
 If you are unsure whether you should Smerge or Ediff, then use the
 former.  It is much easier to understand and use, and except for
-truely complex conflicts, the latter is usually overkill.
truly complex conflicts, the latter is usually overkill.
 
 ** Rebasing
*** _ :ignore:
 
 Also see [[man:git-rebase]]  For information on how to resolve
 conflicts that occur during rebases see the preceding section.
@@ -4034,15 +4720,23 @@ See [[*Information About In-Progress Rebase]].
   commits that are reachable from head but not from the selected
   branch TARGET are being rebased."
 
-- Key: r o, magit-rebase-subset
- Key: r s, magit-rebase-subset
 
   Start a non-interactive rebase sequence with commits from START to
   ~HEAD~ onto NEWBASE.  START has to be selected from a list of recent
   commits.
 
-Note that the popup also features the infix argument ~--interactive~.
-This can be used to turn one of the above non-interactive rebase
-variants into an interactive rebase.
By default Magit uses the ~--autostash~ argument, which causes
uncommitted changes to be stored in a stash before the rebase begins.
These changes are restored after the rebase completes and if possible
the stash is removed.  If the stash does not apply cleanly, then the
stash is not removed.  In case something goes wrong when resolving
the conflicts, this allows you to start over.

Even though one of the actions is dedicated to interactive rebases,
the popup also features the infix argument ~--interactive~.  This can be
used to turn one of the other, non-interactive rebase variants into an
interactive rebase.
 
 For example if you want to clean up a feature branch and at the same
 time rebase it onto ~master~, then you could use ~r-iu~.  But we recommend
@@ -4072,6 +4766,10 @@ is not enabled in the popup.
 
   Reword a single older commit using rebase.
 
- Key: r k, magit-rebase-remove-commit

  Remove a single older commit using rebase.

 When a rebase is in progress, then the popup buffer features these
 commands instead.
 
@@ -4199,17 +4897,17 @@ commands instead.
 *** Information About In-Progress Rebase
 
 While a rebase sequence is in progress, the status buffer features a
-section which lists the commits that have already been applied as well
section that lists the commits that have already been applied as well
 as the commits that still have to be applied.
 
 The commits are split in two halves.  When rebase stops at a commit,
-either because the user has to deal with a conflict or explicitly
-requested that rebase stops at that commit, then point is placed on
-the commit that separates the two groups, i.e. on ~HEAD~.  The commits
-above it have not been applied yet, while it and the commits below it
-have already been applied.  In between these two groups of applied and
-yet-to-be applied commits, there sometimes is a commit which has been
-dropped.
either because the user has to deal with a conflict or because s/he
explicitly requested that rebase stops at that commit, then point is
placed on the commit that separates the two groups, i.e. on ~HEAD~.  The
commits above it have not been applied yet, while the ~HEAD~ and the
commits below it have already been applied.  In between these two
groups of applied and yet-to-be applied commits, there sometimes is a
commit which has been dropped.
 
 Each commit is prefixed with a word and these words are additionally
 shown in different colors to indicate the status of the commits.
@@ -4225,7 +4923,7 @@ The following colors are used:
 - The green commit is the commit the rebase sequence stopped at.  If
   this is the same commit as ~HEAD~ (e.g. because you haven't done
   anything yet after rebase stopped at the commit, then this commit is
-  shown in blue, not green.  There can only be a green and a blue
  shown in blue, not green.  There can only be a green *and* a blue
   commit at the same time, if you create one or more new commits after
   rebase stops at a commit.
 
@@ -4241,75 +4939,108 @@ The following words are used:
   in the buffer used to edit the rebase sequence.  See [[*Editing Rebase
   Sequences]].
 
-- The commit prefixed with ~onto~ is the commit on top of which all the
-  other commits are being re-applied.  Like the commits that have
-  already been re-applied, it is reachable from ~HEAD~, but unlike those
-  it has not actually been re-applied during the current session - it
-  wasn't touched at all.
-
-- Commits prefixed with ~done~ have already been re-applied.  Not all
-  commits that have already been applied are prefixed with this word,
-  though.
-
-- When a commit is prefixed with ~void~, then that indicates that Magit
-  knows for sure that all the changes in that commit have been applied
-  using several new commits.  This commit is no longer reachable from
-  ~HEAD~, and it also isn't one of the commits that will be applied when
-  resuming the session.
-
-- When a commit is prefixed with ~join~, then that indicates that the
-  rebase sequence stopped at that commit due to a conflict - you now
-  have to join (merge) the changes with what has already been
-  applied.  In a sense this is the commit rebase stopped at, but while
-  its effect is already in the index and in the worktree (with
-  conflict markers), the commit itself has not actually been applied
-  yet (it isn't the ~HEAD~).  So it is shown in yellow, like the other
-  commits that still have to be applied.
-
-- When a commit is prefixed with ~goal~, ~same~, or ~work~, then that
-  indicates that you reset to an earlier commit (and that this commit
-  therefore is no longer reachable from ~HEAD~), but that it might still
-  be possible to create a new commit with the exact same tree or at
-  least the same patch-id [fn:patch-id], without manually editing any
-  file.  Or at the very least that there are some uncommitted
-  remaining, which may or may not originate from that commit.
-
-  - When a commit is prefixed with ~goal~, then that indicates that it
-    is still possible to create a commit with the exact same tree
-    (the "goal") without manually editing a file, by simply committing
-    the index (or, provided nothing is already staged, by staging all
-    unstaged changes and then committing that).  This is the case when
-    the original tree exists in the index or worktree in untainted
-    form.
-
-  - When a commit is prefixed with ~same~, then that indicates that it
-    is no longer possible to create a commit with the exact same tree,
-    but that it is still possible to create a commit with the same
-    patch-id.  This would be the case if you created a new commit with
-    other changes, but the changes from the original commit still
-    exist in the index and/or working tree in untainted form.
-
-  - When a commit is prefixed with ~work~, then that indicates that you
-    are working with the changes from that commit after resetting to
-    an earlier commit.  There are changes in the index and/or working
-    tree and some of them likely originate from that commit.
-
-- When a commit is prefixed with ~poof~ or ~gone~, then that indicates
-  that you reset to an earlier commit (and that this commit therefore
-  is no longer reachable from ~HEAD~), and that there are no
-  uncommitted changes remaining which might allow you to create a new
-  commit with the same tree or at least the same patch-id.
-
-  - When a commit is prefixed with ~poof~, then that indicates that it
-    is no longer reachable from ~HEAD~, but that it has been replaced
-    with one or more commits, which together have the exact same
-    effect.
-
-  - When a commit is prefixed with ~gone~, then that indicates that it
-    is no longer reachable from ~HEAD~ and that we also cannot determine
-    whether its changes are still in effect in one or more new
-    commits.  They might be, but if so, then there must also be other
-    changes which makes it impossible to know for sure.
- Commits prefixed with ~done~ and ~onto~ have already been applied.
  It is possible for such a commit to be the ~HEAD~, in which case it
  is blue.  Otherwise it is grey.

  - The commit prefixed with ~onto~ is the commit on top of which all
    the other commits are being re-applied.  This commit itself did
    not have to be re-applied, it is the commit rebase did rewind to
    before starting to re-apply other commits.

  - Commits prefixed with ~done~ have already been re-applied.  This
    includes commits that have been re-applied but also new commits
    that you have created during the rebase.

- All other commits, those not prefixed with any of the above words,
  are in some way related to the commit at which rebase stopped.

  To determine whether a commit is related to the stopped-at commit
  their hashes, trees and patch-ids [fn:patch-id] are being compared.
  The commit message is not used for this purpose.

  Generally speaking commits that are related to the stopped-at commit
  can have any of the used colors, though not all color/word
  combinations are possible.

  Words used for stopped-at commits are:

  - When a commit is prefixed with ~void~, then that indicates that
    Magit knows for sure that all the changes in that commit have been
    applied using several new commits.  This commit is no longer
    reachable from ~HEAD~, and it also isn't one of the commits that
    will be applied when resuming the session.

  - When a commit is prefixed with ~join~, then that indicates that the
    rebase sequence stopped at that commit due to a conflict - you now
    have to join (merge) the changes with what has already been
    applied.  In a sense this is the commit rebase stopped at, but
    while its effect is already in the index and in the worktree (with
    conflict markers), the commit itself has not actually been applied
    yet (it isn't the ~HEAD~).  So it is shown in yellow, like the other
    commits that still have to be applied.

  - When a commit is prefixed with ~stop~ or a /blue/ or /green/ ~same~, then
    that indicates that rebase stopped at this commit, that it is
    still applied or has been applied again, and that at least its
    patch-id is unchanged.

    - When a commit is prefixed with ~stop~, then that indicates that
      rebase stopped at that commit because you requested that
      earlier, and its patch-id is unchanged.  It might even still be
      the exact same commit.

    - When a commit is prefixed with a /blue/ or /green/ ~same~, then that
      indicates that while its tree or hash changed, its patch-id did
      not.  If it is blue, then it is the ~HEAD~ commit (as always for
      blue).  When it is green, then it no longer is ~HEAD~ because
      other commit have been created since (but before continuing the
      rebase).

  - When a commit is prefixed with ~goal~, a /yellow/ ~same,~ or ~work~, then
    that indicates that rebase applied that commit but that you then
    reset ~HEAD~ to an earlier commit (likely to split it up into
    multiple commits), and that there are some uncommitted changes
    remaining which likely (but not necessarily) originate from that
    commit.

    - When a commit is prefixed with ~goal~, then that indicates that it
      is still possible to create a new commit with the exact same
      tree (the "goal") without manually editing any files, by
      committing the index, or by staging all changes and then
      committing that.  This is the case when the original tree still
      exists in the index or worktree in untainted form.

    - When a commit is prefixed with a yellow ~same~, then that
      indicates that it is no longer possible to create a commit with
      the exact same tree, but that it is still possible to create a
      commit with the same patch-id.  This would be the case if you
      created a new commit with other changes, but the changes from
      the original commit still exist in the index or working tree in
      untainted form.

    - When a commit is prefixed with ~work~, then that indicates that
      you reset ~HEAD~ to an earlier commit, and that there are some
      staged and/or unstaged changes (likely, but not necessarily)
      originating from that commit.  However it is no longer possible
      to create a new commit with the same tree or at least the same
      patch-id because you have already made other changes.

  - When a commit is prefixed with ~poof~ or ~gone~, then that indicates
    that rebase applied that commit but that you then reset ~HEAD~ to an
    earlier commit (likely to split it up into multiple commits), and
    that there are no uncommitted changes.

    - When a commit is prefixed with ~poof~, then that indicates that it
      is no longer reachable from ~HEAD~, but that it has been replaced
      with one or more commits, which together have the exact same
      effect.

    - When a commit is prefixed with ~gone~, then that indicates that it
      is no longer reachable from ~HEAD~ and that we also cannot
      determine whether its changes are still in effect in one or more
      new commits.  They might be, but if so, then there must also be
      other changes which makes it impossible to know for sure.
 
 Do not worry if you do not fully understand the above.  That's okay,
 you will acquire a good enough understanding through practice.
@@ -4321,17 +5052,18 @@ importantly these sequences only support "picking" a commit but not
 other actions such as "rewording", and they do not keep track of the
 commits which have already been applied.
 
-[fn:patch-id] The patch-id is a hash of the /changes/ introduced by
-commit.  It differs from hash of the commit itself, which is a hash of
-the result of applying that change (i.e. the resulting trees and
-blobs) as well as author and committer information, the commit
[fn:patch-id] The patch-id is a hash of the /changes/ introduced by a
commit.  It differs from the hash of the commit itself, which is a
hash of the result of applying that change (i.e. the resulting trees
and blobs) as well as author and committer information, the commit
 message, and the hashes of the parents of the commit.  The patch-id
 hash on the other hand is created only from the added and removed
-lines, even line numbers and whitespace are created when calculating
-the hash.  The patch-ids of two commits can be used to answer the
-question "Do these two commits make the same change?".
lines, even line numbers and whitespace changes are ignored when
calculating this hash.  The patch-ids of two commits can be used to
answer the question "Do these commits make the same change?".
 
 ** Cherry Picking
*** _ :ignore:
 
 Also see [[man:git-cherry-pick]]
 
@@ -4345,16 +5077,17 @@ features the following commands.
 
 - Key: A A, magit-cherry-pick
 
-  Cherry-pick a commit.  Prompt for a commit, defaulting to the commit
-  at point.  If the region selects multiple commits, then pick all of
-  them, without prompting.
  This command copies COMMITS from another branch onto the current
  branch.  If the region selects multiple commits, then those are
  copied, without prompting.  Otherwise the user is prompted for a
  commit or range, defaulting to the commit at point.
 
 - Key: A a, magit-cherry-apply
 
-  Apply the changes in a commit to the working tree, but do not commit
-  them.  Prompt for a commit, defaulting to the commit at point.  If
-  the region selects multiple commits, then apply all of them, without
-  prompting.
  This command applies the changes in COMMITS from another branch onto
  the current branch.  If the region selects multiple commits, then
  those are used, without prompting.  Otherwise the user is prompted
  for a commit or range, defaulting to the commit at point.
 
   This command also has a top-level binding, which can be invoked without
   using the popup by typing ~a~ at the top-level.
@@ -4424,35 +5157,33 @@ Also see [[man:git-reset]]
   defaulting to the commit at point.  The working tree is kept as-is.
   With a prefix argument also reset the working tree.
 
-- Key: M-x magit-reset-index, magit-reset-index
-
-  Reset the index to some commit read from the user and defaulting to
-  the commit at point.  Keep the ~HEAD~ and working tree as-is, so if
-  the commit refers to the ~HEAD~, then this effectively unstages all
-  changes.
-
-- Key: M-x magit-reset-head, magit-reset-head
- Key: X m, magit-reset-head
 
   Reset the ~HEAD~ and index to some commit read from the user and
   defaulting to the commit at point.  The working tree is kept as-is.
 
-- Key: M-x magit-reset-soft, magit-reset-soft
- Key: X s, magit-reset-soft
 
   Reset the ~HEAD~ to some commit read from the user and defaulting
   to the commit at point.  The index and the working tree are kept
   as-is.
 
-- Key: M-x magit-reset-hard, magit-reset-hard
- Key: X h, magit-reset-hard
 
   Reset the ~HEAD~, index, and working tree to some commit read from the
   user and defaulting to the commit at point.
 
-- Key: M-x magit-file-checkout, magit-file-checkout
- Key: X i, magit-reset-index
 
-  Update file in the working tree and index to the contents from a
-  revision.
  Reset the index to some commit read from the user and defaulting to
  the commit at point.  Keep the ~HEAD~ and working tree as-is, so if
  the commit refers to the ~HEAD~, then this effectively unstages all
  changes.
 
-  Both the revision and file are read from the user.
- Key: X f, magit-file-checkout

  Update file in the working tree and index to the contents from a
  revision.  Both the revision and file are read from the user.
 
 ** Stashing
 
@@ -4532,14 +5263,21 @@ Also see [[man:git-stash]]
 
 - Key: z b, magit-stash-branch
 
-  Create and checkout a new BRANCH from STASH.
  Create and checkout a new BRANCH from STASH.  The branch starts at
  the commit that was current when the stash was created.

- Key: z B, magit-stash-branch-here

  Create and checkout a new BRANCH using ~magit-branch~ with the current
  branch or ~HEAD~ as the starting-point.  Then apply STASH, dropping it
  if it applies cleanly.
 
 - Key: z f, magit-stash-format-patch
 
   Create a patch from STASH.
 
 - Key: k, magit-stash-clear
-  

   Remove all stashes saved in REF's reflog by deleting REF.
 
 - Key: z l, magit-stash-list
@@ -4567,6 +5305,12 @@ Also see [[man:git-stash]]
 
 * Transferring
 ** Remotes
*** The Remote Popup

The popup ~magit-remote-popup~ is used to add remotes and to make
changes to existing remotes.  This popup only deals with remotes
themselves, not with branches or the transfer of commits.  Those
features are available from separate popups.
 
 Also see [[man:git-remote]]
 
@@ -4575,6 +5319,22 @@ Also see [[man:git-remote]]
   This prefix command shows the following suffix commands along with
   the appropriate infix arguments in a popup buffer.
 
- User Option: magit-remote-popup-show-variables

  This option controls whether the ~magit-remote-popup~ shows remote
  related Git variables.  When set to nil, no variables are displayed
  directly in this popup, and the sub-popup ~magit-remote-config-popup~
  has to be used instead to view and change remote related variables.

- Key: M C, magit-remote-config-popup

  This command shows remote related variables in a separate popup.  By
  default this asks the user for which remote the variables should be
  shown.  When ~magit-remote-popup-show-variables~ is ~nil~, then it shows
  the variables for the upstream of the current branch or "origin" it
  that branch has no remote upstream.  To select another remote use a
  prefix argument.

 - Key: M a, magit-remote-add
 
   Add a remote and fetch it.  The remote name and url are read in the
@@ -4594,6 +5354,12 @@ Also see [[man:git-remote]]
 
   Delete a remote, read from the minibuffer.
 
- Key: M p, magit-remote-prune-refspecs

  Remove stale refspecs and tracking branches for REMOTE.  If there
  are only stale refspecs, then offer to either delete the remote or
  replace the refspecs with the default refspec instead.

 - User Option: magit-remote-add-set-remote.pushDefault
 
   Whether to set the value of ~remote.pushDefault~ after adding a
@@ -4604,6 +5370,49 @@ Also see [[man:git-remote]]
   is a string, then set without asking, provided that the name of the added
   remote is equal to that string and the variable isn't already set.
 
*** The Remote Config Popup

- Command: magit-remote-config-popup

  This prefix command shows the following remote-related Git variables
  in a popup buffer.  The values can be changed from that buffer.

  This popup is a sub-popup of the ~magit-remote-popup~ in which "C" is
  bound to this popup.

The following variables are used to configure a specific remote.  The
values are being displayed for the upstream remote of the current
branch.  To change the value for another remote invoke
~magit-remote-config-popup~ with a prefix argument.

- Variable: remote.NAME.url

  This variable specifies the url of the remote named NAME.  It can
  have multiple values.

- Variable: remote.NAME.fetch

  The refspec used when fetching from the remote named NAME.  It can
  have multiple values.

- Variable: remote.NAME.pushurl

  This variable specifies the url used for fetching from the remote
  named NAME.  If it is not specified, then ~remote.NAME.url~ is used
  instead.  It can have multiple values.

- Variable: remote.NAME.push

  The refspec used when pushing to the remote named NAME.  It can
  have multiple values.

- Variable: remote.NAME.tagOpts

  This variable specifies what tags are fetched by default.  If the
  value is ~--no-tags~ then no tags are fetched.  If the value is
  ~--tags~, then all tags are fetched.  If this variable has not value,
  then only tags are fetched that are reachable from fetched branches.

 ** Fetching
 
 For information about the differences between the /upstream/ and the
@@ -4706,7 +5515,7 @@ Also see [[man:git-push]]
   Push the current branch to its upstream branch.
 
   When ~magit-push-current-set-remote-if-missing~ is non-nil and the
-  push-remote is not configured, then read the upstram from the
  push-remote is not configured, then read the upstream from the
   user, set it, and then push to it.  With a prefix argument the
   push-remote can be changed before pushed to it.
 
@@ -4810,9 +5619,12 @@ them to the popup.
 
   Request that upstream pulls from your public repository.
 
It is also possible to save a plain patch file by using ~C-x C-w~ inside
a ~magit-diff-mode~ or ~magit-revision-mode~ buffer.

 ** Applying Patches
 
-Also see [[man:git-am]]
Also see [[man:git-am]] and [[man:git-apply]]
 
 - Key: w, magit-am-popup
 
@@ -4829,6 +5641,9 @@ Also see [[man:git-am]]
 
   Apply the patches from a maildir.
 
When an "am" operation is in progress, then the popup buffer features
these commands instead.

 - Key: w w, magit-am-continue
 
   Resume the current patch applying sequence.
@@ -4842,6 +5657,19 @@ Also see [[man:git-am]]
   Abort the current patch applying sequence.  This discards all
   changes made since the sequence started.
 
In addition to the commands listed at the top, the "am" popup also has
a binding for the related "patch" popup.

- Key: w a, magit-patch-apply-popup

  This prefix command shows the following suffix commands along with
  the appropriate infix arguments in a popup buffer.

- Key: w a a, magit-patch-apply

  This command applies a simple patch file, which may not contain any
  Git metadata in addition to the actual diff.

 * Miscellaneous
 ** Tagging
 
@@ -4896,25 +5724,6 @@ Also see [[man:git-notes]]
 
   Remove notes about unreachable commits.
 
-- Key: T s, magit-notes-set-ref
-
-  Set the current notes ref to a the value read from the user.  The
-  ref is made current by setting the value of the Git variable
-  ~core.notesRef~.  With a prefix argument change the global value
-  instead of the value in the current repository.  When this is
-  undefined, then "refs/notes/commit" is used.
-
-  Other ~magit-notes-*~ commands, as well as the sub-commands of Git's
-  ~note~ command, default to operate on that ref.
-
-- Key: T S, magit-notes-set-display-refs
-
-  Set notes refs to be display in addition to "core.notesRef".  This
-  reads a colon separated list of notes refs from the user.  The
-  values are stored in the Git variable ~notes.displayRef~.  With a
-  prefix argument GLOBAL change the global values instead of the
-  values in the current repository.
-
 It is possible to merge one note ref into another.  That may result in
 conflicts which have to resolved in the temporary worktree
 ".git/NOTES_MERGE_WORKTREE".
@@ -4937,13 +5746,30 @@ following suffix commands, instead of those listed above.
 
   Abort the current notes ref merge.
 
The following variables control what notes reference ~magit-notes-*~,
~git notes~ and ~git show~ act on and display.  Both the local and global
values are displayed and can be modified.

- Variable: core.notesRef

  This variable specifies the notes ref that is displayed by default
  and which commands act on by default.

- Variable: notes.displayRef

  This variable specifies additional notes ref to be displayed in
  addition to the ref specified by ~core.notesRef~.  It can have
  multiple values and may end with ~*~ to display all refs in the
  ~refs/notes/~ namespace (or ~**~ if some names contain slashes).

 ** Submodules
*** _ :ignore:
 
 Also see [[man:git-submodule]]
 
 *** Listing Submodules
 
-The command ~magit-list-submodule~ displays a list of the current
The command ~magit-list-submodules~ displays a list of the current
 repository's submodules in a separate buffer.  It's also possible to
 display information about submodules directly in the status buffer of
 the super-repository by adding ~magit-insert-submodules~ to the hook
@@ -4973,7 +5799,8 @@ the super-repository by adding ~magit-insert-submodules~ to the hook
 - Function: magit-insert-submodules
 
   Insert sections for all submodules.  For each section insert the
-  path, the branch, and the output of ~git describe --tags~.
  path, the branch, and the output of ~git describe --tags~,
  or, failing that, the abbreviated HEAD commit hash.
 
   Press ~RET~ on such a submodule section to show its own status buffer.
   Press ~RET~ on the "Modules" section to display a list of submodules
@@ -5015,7 +5842,7 @@ the super-repository by adding ~magit-insert-submodules~ to the hook
 
   Fetch submodule.  With a prefix argument fetch all remotes.
 
-- Key: o i, magit-submodule-init
- Key: o d, magit-submodule-deinit
 
   Unregister the submodule at PATH.
 
@@ -5079,7 +5906,7 @@ beside the ones below, but these didn't fit well anywhere else.
 
 - Key: C-w, magit-copy-buffer-revision
 
-  This command save the revision being displayed in the current buffer
  This command saves the revision being displayed in the current buffer
   to the ~kill-ring~ and also pushes it to the ~magit-revision-stack~.  It
   is mainly intended for use in ~magit-revision-mode~ buffers, the only
   buffers where it is always unambiguous exactly which revision should
@@ -5149,7 +5976,7 @@ A---B---C              refs/heads/master
      \   \
       \   CW0---CW1    refs/wip/wtree/refs/heads/master
        \
-        BW0---BW1      refs/wip/wtree/refs/heads/master@@@{2@}
        BW0---BW1      refs/wip/wtree/refs/heads/master@{2}
 #+END_EXAMPLE
 
 The fork-point of the index wip ref is not changed until some change
@@ -5158,7 +5985,7 @@ commit does not change the fork-point of the working tree wip ref.  The
 fork-points are not adjusted until there actually is a change that
 should be committed to the respective wip ref.
 
-To view the log for the a branch and its wip refs use the commands
To view the log for a branch and its wip refs use the commands
 ~magit-wip-log~ and ~magit-wip-log-current~.  You should use ~--graph~ when
 using these commands.  Alternatively you can use the reflog to show
 all commits that ever existed on a wip ref.  You can then recover lost
@@ -5185,7 +6012,7 @@ which might seem excessive, but allows fine tuning of when exactly
 changes are being committed to the wip refs.  Enabling all modes makes
 it less likely that a change slips through the cracks.
 
-Setting the below variable directly does not take effect; either
Setting the following variables directly does not take effect; either
 customize them or call the respective mode function.
 
 - User Option: magit-wip-after-save-mode
@@ -5292,12 +6119,11 @@ few key bindings, but this might be extended in the future.
 - Key: C-c M-g d, magit-diff-buffer-file
 
   This command shows the diff for the file of blob that the current
-  buffer visits.  Renames are followed when a prefix argument is used
-  or when ~--follow~ is part of ~magit-diff-arguments~.
  buffer visits.
 
 - User Option: magit-diff-buffer-file-locked
 
-  This option controls whether ~magit-diff-buffer-file~ uses a decicated
  This option controls whether ~magit-diff-buffer-file~ uses a dedicated
   buffer.  See [[*Modes and Buffers]].
 
 - Key: C-c M-g L, magit-log-buffer-file-popup
@@ -5311,11 +6137,12 @@ few key bindings, but this might be extended in the future.
 
   This command shows the log for the file of blob that the current
   buffer visits.  Renames are followed when a prefix argument is used
-  or when ~--follow~ is part of ~magit-log-arguments~.
  or when ~--follow~ is part of ~magit-log-arguments~.  When the
  region is active, the log is restricted to the selected line range.
 
 - User Option: magit-log-buffer-file-locked
 
-  This option controls whether ~magit-log-buffer-file~ uses a decicated
  This option controls whether ~magit-log-buffer-file~ uses a dedicated
   buffer.  See [[*Modes and Buffers]].
 
 - Key: C-c M-g b, magit-blame-popup
@@ -5349,6 +6176,7 @@ bindings, but this might be extended.
   Kill the current buffer.
 
 * Customizing
** _ :ignore:
 
 Both Git and Emacs are highly customizable.  Magit is both a Git
 porcelain as well as an Emacs package, so it makes sense to customize
@@ -5372,7 +6200,7 @@ to the following.
   this case the ~--prune~ argument in ~magit-fetch-popup~ might be active
   or inactive depending on the value of ~magit-fetch-arguments~ only,
   but that doesn't keep the Git variable from being honored by the
-  suffix commands anyway.  So pruning might happen despite the the
  suffix commands anyway.  So pruning might happen despite the
   ~--prune~ arguments being displayed in a way that seems to indicate
   that no pruning will happen.
 
@@ -5430,6 +6258,7 @@ For example:
   #+END_SRC
 
 ** Essential Settings
*** _ :ignore:
 
 The next two sections list and discuss several variables that many
 users might want to customize, for safety and/or performance reasons.
@@ -5468,6 +6297,7 @@ but to make an informed decision you should see [[*Risk of Reverting
 Automatically]].
 
 *** Performance
**** _ :ignore:
 
 After Magit has run ~git~ for side-effects, it also refreshes the
 current Magit buffer and the respective status buffer.  This is
@@ -5484,7 +6314,7 @@ but also requires major refactoring.
 
 Meanwhile you can tell Magit to only automatically refresh the current
 Magit buffer, but not the status buffer.  If you do that, then the
-status buffer is only refreshed automatically if it itself is the
status buffer is only refreshed automatically if it is the
 current buffer.
 
 #+BEGIN_SRC emacs-lisp
@@ -5494,16 +6324,16 @@ current buffer.
 You should also check whether any third-party packages have added
 anything to ~magit-refresh-buffer-hook~, ~magit-status-refresh-hook~,
 ~magit-pre-refresh-hook~, and ~magit-post-refresh-hook~.  If so, then
-check whether those additions impacts performance significantly.
check whether those additions impact performance significantly.
 Setting ~magit-refresh-verbose~ and then inspecting the output in the
 ~*Messages*~ buffer, should help doing so.
 
-Magit also reverts buffers which visit files located inside the
-current repository, when the visited file changes on disk.  That is
Magit also reverts buffers for visited files located inside the
current repository when the visited file changes on disk.  That is
 implemented on top of ~auto-revert-mode~ from the built-in library
 ~autorevert~.  To figure out whether that impacts performance, check
 whether performance is significantly worse, when many buffers exist
-and/or when some buffers visit files using Tramp.  If so, then this
and/or when some buffers visit files using TRAMP.  If so, then this
 should help.
 
 #+BEGIN_SRC emacs-lisp
@@ -5524,34 +6354,10 @@ repositories, then you might want to disable certain features on a
 per-repository or per-repository-class basis only.  See
 [[*Per-Repository Configuration]].
 
-**** Microsoft Windows Performance
-
-In order to update the status buffer, ~git~ has to be run a few dozen
-times.  That is only problematic on Microsoft Windows, because that
-operating system is exceptionally slow at starting processes.  Sadly
-this is an issue that can only be fixed by Microsoft itself, and they
-don't appear to be particularly interested in doing so.
-
-Beside the subprocess issue, there also exist other Window-specific
-performance issues, some of which can be worked around.  The
-maintainers of "Git for Windows" try to reduce their effect, and in
-order to benefit from the latest performance tweaks, should always
-use the latest release.  Magit too tries to work around some
-Windows-specific issues.
-
-According to some sources setting the following Git variables can also
-help.
-
-#+BEGIN_SRC shell-script
-  git config --global core.preloadindex true   # default since v2.1
-  git config --global core.fscache true        # default since v2.8
-  git config --global gc.auto 256
-#+END_SRC
-
-You should also check whether an anti-virus program is slowing things
-down.
-
 **** Log Performance
:PROPERTIES:
:NONODE: t
:END:
 
 When showing logs, Magit limits the number of commits initially shown
 in the hope that this avoids unnecessary work.  When using ~--graph~ is
@@ -5581,6 +6387,9 @@ merges.  For that reason ~--color~ is not enabled by default anymore.
 Consider leaving it at that.
 
 **** Diff Performance
:PROPERTIES:
:NONODE: t
:END:
 
 If diffs are slow, then consider turning off some optional diff
 features by setting all or some of the following variables to ~nil~:
@@ -5596,6 +6405,9 @@ looking at the same commit in ~magit-diff-mode~, then consider setting
 ~magit-revision-insert-related-refs~ to ~nil~.
 
 **** Refs Buffer Performance
:PROPERTIES:
:NONODE: t
:END:
 
 When refreshing the "references buffer" is slow, then that's usually
 because several hundred refs are being displayed.  The best way to
@@ -5613,6 +6425,9 @@ actually all exist.  You can do so by pruning branches which no longer
 exist using ~f-pa~.
 
 **** Committing Performance
:PROPERTIES:
:NONODE: t
:END:
 
 When you initiate a commit, then Magit by default automatically shows
 a diff of the changes you are about to commit.  For large commits this
@@ -5627,16 +6442,19 @@ using:
 
 Then you can type ~C-c C-d~ to show the diff when you actually want to
 see it, but only then.  Alternatively you can leave the hook alone and
-just type ~C-g~ in those cases when it takes to long to generate the
just type ~C-g~ in those cases when it takes too long to generate the
 diff.  If you do that, then you will end up with a broken diff buffer,
 but doing it this way has the advantage that you usually get to see
 the diff, which is useful because it increases the odds that you spot
 potential issues.
 
 **** The Built-In VC Package
:PROPERTIES:
:NONODE: t
:END:
 
 Emacs comes with a version control interface called "VC", see
-[[info:emacs#Version Control]].  It is enabled be default and if you don't
[[info:emacs#Version Control]].  It is enabled be default, and if you don't
 use it in addition to Magit, then you should disable it to keep it
 from performing unnecessary work:
 
@@ -5644,14 +6462,68 @@ from performing unnecessary work:
   (setq vc-handled-backends nil)
 #+END_SRC
 
-You can also disable its use only for Git but keep using it when using
You can also disable its use for Git but keep using it when using
 another version control system:
 
 #+BEGIN_SRC emacs-lisp
   (setq vc-handled-backends (delq 'Git vc-handled-backends))
 #+END_SRC
 
**** Microsoft Windows Performance

In order to update the status buffer, ~git~ has to be run a few dozen
times.  That is problematic on Microsoft Windows, because that
operating system is exceptionally slow at starting processes.  Sadly
this is an issue that can only be fixed by Microsoft itself, and they
don't appear to be particularly interested in doing so.

Beside the subprocess issue, there are also other Windows-specific
performance issues. Some of these have workarounds.  The
maintainers of "Git for Windows" try to improve performance on Windows.
Always use the latest release in order to benefit from the latest
performance tweaks.  Magit too tries to work around some
Windows-specific issues.

According to some sources, setting the following Git variables can also
help.

#+BEGIN_SRC shell-script
  git config --global core.preloadindex true   # default since v2.1
  git config --global core.fscache true        # default since v2.8
  git config --global gc.auto 256
#+END_SRC

You should also check whether an anti-virus program is affecting
performance.

**** MacOS Performance

On macOS Emacs currently creates child processes using ~fork~.  It
appears that this also copies GUI resources.  The result is that
forking takes about 30 times as long on Darwin than on Linux.  And
because Magit starts many ~git~ processes even when doing simple things,
that makes quite a difference.

On the ~master~ branch Emacs now uses ~vfork~ when possible, like this was
already done on Linux, and now child creation only takes about twice
as long on Darwin.  See [fn:mac1] for more information.

Nobody knows when the changes on the ~master~ branch will be released as
~26.1~, but it is still a long way off.  You might want to get your
hands on this change before then.  The easiest way to get a patched
Emacs is to install the ~emacs-plus~ formula [fn:mac2] using ~homebrew~.
The change has been backported, so you get it not only when using
~--HEAD~, but also when using ~--devel~ or when installing the latest
release (by not using a version argument).

Alternatively you can apply the backport [fn:mac3] manually.

[fn:mac1] https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-04/msg00201.html
[fn:mac2] https://github.com/d12frosted/homebrew-emacs-plus
[fn:mac3] https://gist.githubusercontent.com/aaronjensen/f45894ddf431ecbff78b1bcf533d3e6b/raw/6a5cd7f57341aba673234348d8b0d2e776f86719/Emacs-25-OS-X-use-vfork.patch

 * Plumbing
** _ :ignore:
 
 The following sections describe how to use several of Magit's core
 abstractions to extend Magit itself or implement a separate extension.
@@ -5662,11 +6534,12 @@ packages, without having to depend on Magit.  These libraries are
 described in separate manuals, see [[info:with-editor]] and
 [[info:magit-popup]].
 
-If you are trying to find an unused key that you can bound to a
If you are trying to find an unused key that you can bind to a
 command provided by your own Magit extension, then checkout
 https://github.com/magit/magit/wiki/Plugin-Dispatch-Key-Registry.
 
 ** Calling Git
*** _ :ignore:
 
 Magit provides many specialized functions for calling Git.  All of
 these functions are defined in either ~magit-git.el~ or ~magit-process.el~
@@ -5674,15 +6547,15 @@ and have one of the prefixes ~magit-run-~, ~magit-call-~, ~magit-start-~,
 or ~magit-git-~ (which is also used for other things).
 
 All of these functions accept an indefinite number of arguments, which
-are strings that specify command line arguments for git (or in some
are strings that specify command line arguments for Git (or in some
 cases an arbitrary executable).  These arguments are flattened before
 being passed on to the executable; so instead of strings they can also
 be lists of strings and arguments that are ~nil~ are silently dropped.
 Some of these functions also require a single mandatory argument
 before these command line arguments.
 
-Roughly speaking these functions run Git either to get some value or
-for side-effect.  The functions that return a value are useful to
Roughly speaking, these functions run Git either to get some value or
for side-effects.  The functions that return a value are useful to
 collect the information necessary to populate a Magit buffer, while
 the others are used to implement Magit commands.
 
@@ -5694,8 +6567,8 @@ trigger a refresh when the executable has finished.
 
 *** Getting a Value from Git
 
-These functions run Git in order to get a value, either its exit
-status or its output.  Of course you could also use them to run Git
These functions run Git in order to get a value, an exit
status, or output.  Of course you could also use them to run Git
 commands that have side-effects, but that should be avoided.
 
 - Function: magit-git-exit-code &rest args
@@ -5747,8 +6620,8 @@ commands that have side-effects, but that should be avoided.
   add a section containing git's standard error in the current
   repository's process buffer.
 
-When an error occurs when using one of the above functions, then that
-is usually due to a bug, i.e. the use of an argument which is not
If an error occurs when using one of the above functions, then that
is usually due to a bug, i.e. using an argument which is not
 actually supported.  Such errors are usually not reported, but when
 they occur we need to be able to debug them.
 
@@ -5841,7 +6714,7 @@ the refresh because that also automatically moves to the next change.
   first insert the raw output at point.  If there is no output call
   ~magit-cancel-section~.  Otherwise temporarily narrow the buffer to
   the inserted text, move to its beginning, and then call function
-  WASHER with no argument.
  WASHER with ARGS as its sole argument.
 
 And now for the asynchronous variants.
 
@@ -6222,19 +7095,9 @@ where ~*~ may be something like ~diff~) with the value of
   of this variable and then calling this ~magit-refresh-function~.
 
 ** Conventions
-*** Confirmation and Completion
-
-Dangerous operations that may lead to data loss have to be confirmed
-by default.  With a multi-section selection, this is done using
-questions that can be answered with "yes" or "no".  When the region isn't
-active, or if it doesn't constitute a valid section selection, then
-such commands instead read a single item in the minibuffer.  When the
-value of the current section is among the possible choices, then that
-is presented as default choice.  To confirm the action on a single
-item, the user has to answer ~RET~ (instead of "yes"), and to abort, ~C-g~
-(instead of "no").  But alternatively the user may also select another
-item, just like if the command had been invoked with no suitable
-section at point at all.
*** _ :ignore:

Also see [[*Completion and Confirmation]].
 
 *** Theming Faces
 
@@ -6378,12 +7241,15 @@ all.
 :PROPERTIES:
 :APPENDIX:   t
 :END:
** _ :ignore:
 
 The next two nodes lists frequently asked questions.  For a list of
 frequently *and recently* asked questions, i.e. questions that haven't
 made it into the manual yet, see
 https://github.com/magit/magit/wiki/FAQ.
 
Please also use the [[*Debugging Tools]].

 ** FAQ - How to ...?
 *** How to show git's output?
 
@@ -6392,10 +7258,10 @@ isn't available, ~M-x magit-process-buffer~).  This will show a buffer
 containing a section per git invocation; as always press ~TAB~ to expand
 or collapse them.
 
-By default git's output is only inserted into the process buffer if it
-is run for side-effects.  When the output is consumed in some way then
-also inserting it into the process buffer would be to expensive.  For
-debugging purposes it's possible to do so anyway by setting
By default, git's output is only inserted into the process buffer if it
is run for side-effects.  When the output is consumed in some way,
also inserting it into the process buffer would be too expensive.  For
debugging purposes, it's possible to do so anyway by setting
 ~magit-git-debug~ to ~t~.
 
 *** How to install the gitman info manual?
@@ -6428,7 +7294,6 @@ also affects the diffs displayed inside Magit.
   echo "*.gpg filter=gpg diff=gpg" > .gitattributes
 #+END_SRC
 
-
 *** How does branching and pushing work?
 
 Please see [[*Branching]] and http://emacsair.me/2016/01/18/magit-2.4
@@ -6444,7 +7309,7 @@ are not.  These two functions are only used by the three commands
 These commands only delegate the task of populating buffers with
 certain revisions to the "internal" functions.  The equally important
 task of determining which revisions are to be compared/merged is not
-delegated.  Instead this is done without any support whatsoever, from
delegated.  Instead this is done without any support whatsoever from
 the version control package/system - meaning that the user has to
 enter the revisions explicitly.  Instead of implementing
 ~ediff-magit-internal~ we provide ~magit-ediff-compare~, which handles
@@ -6591,6 +7456,61 @@ can work around the problem by setting
 ~tramp-ssh-controlmaster-options~. Changing your DNS server (e.g. to
 Google's ~8.8.8.8~) may also be sufficient to work around the issue.
 
*** A branch and tag sharing the same name breaks SOMETHING

Or more generally, ambiguous refnames break SOMETHING.

Magit assumes that refs are named non-ambiguously across the
"refs/heads/", "refs/tags/", and "refs/remotes/" namespaces (i.e., all
the names remain unique when those prefixes are stripped).  We
consider ambiguous refnames unsupported and recommend that you use a
non-ambiguous naming scheme.  However, if you do work with a
repository that has ambiguous refnames, please report any issues you
encounter so that we can investigate whether there is a simple fix.

* Debugging Tools

Magit and its dependencies provide a few debugging tools, and we
appreciate it very much if you use those tools before reporting an
issue.  Please include all relevant output when reporting an
issue.

- Key: M-x magit-version, magit-version

  This command shows the currently used versions of Magit, Git, and
  Emacs in the echo area.  Non-interactively this just returns the
  Magit version.

- Key: M-x magit-emacs-Q-command, magit-emacs-Q-command

  This command shows a debugging shell command in the echo area and
  adds it to the kill ring.  Paste that command into a shell an run
  it.

  This shell command starts ~emacs~ with only ~magit~ and its
  dependencies loaded.  Neither your configuration nor other installed
  packages are loaded.  This makes it easier to determine whether some
  issue lays with Magit or something else.

- Key: M-x magit-debug-git-executable, magit-debug-git-executable

  This command displays a buffer containing information about the
  available and used ~git~ executable(s), and can be useful when
  investigating ~exec-path~ issues.

  Also see [[*Git Executable]].

- Key: M-x with-editor-debug, with-editor-debug

  This command displays a buffer containing information about the
  available and used ~git~ executable(s), and can be useful when
  investigating why Magit (or rather ~with-editor~) cannot find an
  appropriate ~emacsclient~ executable.

  Also see [[info:with-editor#Debugging]].

Please also see the [[*FAQ]].

 * Keystroke Index
 :PROPERTIES:
 :APPENDIX:   t
@@ -6613,6 +7533,27 @@ Google's ~8.8.8.8~) may also be sufficient to work around the issue.
 :INDEX:      vr
 :END:
 
* _ Copying
:PROPERTIES:
:COPYING:    t
:END:

#+BEGIN_QUOTE
Copyright (C) 2015-2018 Jonas Bernoulli <jonas@bernoul.li>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.
#+END_QUOTE

* _ :ignore:

 #  LocalWords:  ARG ARGS CONDITIONs ChangeLog DNS Dired Ediff Ediffing
 #  LocalWords:  Elpa Emacsclient FUNC Flyspell Git Git's Gitk HOOK's
 #  LocalWords:  IDENT Ido Junio LocalWords Magit Magit's Magitian Magitians
@@ -6631,9 +7572,15 @@ Google's ~8.8.8.8~) may also be sufficient to work around the issue.
 #  LocalWords:  sym texinfo theming todo topdir un unhighlighted unpulled
 #  LocalWords:  unpushed unstage unstaged unstages unstaging untracked url
 #  LocalWords:  versa whitespace wip workflow worktree wtree
#  LocalWords:  backported macOS
 
# IMPORTANT: Also update ORG_ARGS and ORG_EVAL in the Makefile.
 # Local Variables:
 # eval: (require 'magit-utils nil t)
 # eval: (require 'org-man     nil t)
# eval: (require 'ox-extra    nil t)
 # eval: (require 'ox-texinfo+ nil t)
# eval: (and (featurep 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# indent-tabs-mode: nil
# org-src-preserve-indentation: nil
 # End:
